
[TOC]


# 2. 模型与数据库

## 2.1 模型

​	模型是关于数据单一、明确的信息源。包含存储数据的基本数据和行为。一般一个模型映射为单个数据库表

基础特征：

- 每一个模型是 django.db.models.Model 的子类
- 模型的每一个属性代表数据库中的一个字段
- django 提供相应的数据库访问 API

### 2.1.1 快速入门

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

此模型会创建下面的数据库：

```sql
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

注意：

- 表名通过模型的元数据生成，也可以进行修改，详见 [Table name](https://docs.djangoproject.com/en/1.11/ref/models/options/#table-names)
- 一个id 字段被自动添加，也可以进行修改，详见 [Automatic primary key fields](https://docs.djangoproject.com/en/1.11/topics/db/models/#automatic-primary-key-fields)
- 上面SQL 是 PostgreSQL 格式的

### 2.1.2 使用模型

​	把包含有自定义模型（models.py）的模块（manage.py startapp）名称，加入到 settings 文件(django-admin startproject )的 INSTALLED_APP 中

```python
INSTALLED_APPS = [
    #...
    'myapp',
    #...
]
```

​	当新加之后，务必使用 manage.py migrate ，以及可选的 manage.py makemigrations

### 2.1.3 字段（fields）

​	字段通过类的属性来指定。注意名称不要与 [models API](https://docs.djangoproject.com/en/1.11/ref/models/instances/) (clean，save，delete)冲突。

示例：

```python
from django.db import models

class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)

class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()
```

#### 字段类型

模型中的字段都应该是 Field 类的实例。Django使用字段类类型决定：

- 数据库存储 列的存储类型

- 生成表格时前端组件的类型

- 简单的校验

  Django 定义的类型通过 [model field reference](https://docs.djangoproject.com/en/1.11/ref/models/fields/#model-field-types) 查看，也可以通过  [Writing custom model fields](https://docs.djangoproject.com/en/1.11/howto/custom-model-fields/) 自定义

#### 字段可选项

每一个字段带一些与字段相关的参数。也有一些通用的参数，例如

| null        | 默认为 False，如果为True，数据库会存储空值作为 NULL        |
| ----------- | ---------------------------------------- |
| blank       | 默认为 False，如果为True，此字段允许使用空白              |
| choices     | 可迭代的二元组，对应前端的可选框（第一个为存储，第二个为显示）          |
| default     | 字段的默认值。可以为值 或 可调用对象                      |
| help_text   | 用于前端的组件显示                                |
| primary_key | 如果为真，此字段为主键。如果没有指定主键，会自己添加。主键字段是只读的，**如果去修改，会创建一个新对象** |
| unique      | 如果为真，表示全表唯一                              |

使用 choices 的示例：（可以使用 get_XX_display() 获取相应的显示值）

```python
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```console
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

#### 自增主键字段

​	Django默认会给每一个模型下面字段：

```python
id = models.AutoField(primary_key=True)
```

#### 冗余字段名称

​	每个字段类型（除 ForeignKey, ManyToManyField , OneToOneField，第一个参数用于指定模型类，因此使用 verbose_name 命名参数）使用可选的第一个位置参数-冗余字段名称。如果没有此参数，Django 使用属性名（下划线转为空格）

​	*用于制表的表头*

#### 关系

##### 多对一关系

​	使用  [`django.db.models.ForeignKey`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey) 。需要使用位置参数，来指定与哪个模型关联。

例如：

```python
from django.db import models

class Manufacturer(models.Model):
    # ...
    pass

class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...
```

​	也可以创建 [recursive relationships](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和[relationships to models not yet defined](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships);

​	推荐外键字段名称为小写的相关模型

​	访问反向关联对象示例：[Following relationships backward example](https://docs.djangoproject.com/en/1.11/topics/db/queries/#backwards-related-objects).

​	[Many-to-one relationship model example](https://docs.djangoproject.com/en/1.11/topics/db/examples/many_to_one/).

##### 多对多关系

​	使用   [`ManyToManyField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField) 来定义。需要使用位置参数，来指定与哪个模型关联。

例如：

```python
from django.db import models

class Topping(models.Model):
    # ...
    pass

class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)
```

​	也可以创建 [recursive relationships](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和[relationships to models not yet defined](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships);

​	推荐ManyToManyField 字段的名称使用能够描述相关模型对象集。

​	ManyToManyField在哪个模型并没有什么关系。但是，只能放在一个中。

​	一般将ManyToManyField 放在需要编辑的对象中。（选择相应的标签）

​	[Many-to-many relationship model example](https://docs.djangoproject.com/en/1.11/topics/db/examples/many_to_many/) 

##### 多对多关系的额外字段

​	当出现其他字段时，需要多余的字段放入中间模型中。使用 through 关键字与中间模型关联。

例如：

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)
```

​	在中间模型中，显试使用外键指明多对多相关的模型。

​	中间模型有以下限制条件:

- 有且只有一个外键到源模型，或者显示使用  [`ManyToManyField.through_fields`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.through_fields).（此处与上面例子不符）
- 使用回环的多对多时，允许两个外键指向同一模型。当多于两个外键时，必须使用  `through_fields`
- 使用中间模型定义回环的多对多时，必须使用[`symmetrical=False`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.symmetrical)
- 中间模型在创建时，应当指定所有字段

```shell
>>> ringo = Person.objects.create(name="Ringo Starr")
>>> paul = Person.objects.create(name="Paul McCartney")
>>> beatles = Group.objects.create(name="The Beatles")
>>> m1 = Membership(person=ringo, group=beatles,
...     date_joined=date(1962, 8, 16),
...     invite_reason="Needed a new drummer.")
>>> m1.save()
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>]>
>>> ringo.group_set.all()
<QuerySet [<Group: The Beatles>]>
>>> m2 = Membership.objects.create(person=paul, group=beatles,
...     date_joined=date(1960, 8, 1),
...     invite_reason="Wanted to form a band.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>

>>> # The following statements will not work
>>> beatles.members.add(john)
>>> beatles.members.create(name="George Harrison")
>>> beatles.members.set([john, paul, ringo, george])

>>> Membership.objects.create(person=ringo, group=beatles,
...     date_joined=date(1968, 9, 4),
...     invite_reason="You've been gone for a month and we miss you.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>, <Person: Ringo Starr>]>
>>> # This will not work because it cannot tell which membership to remove
>>> beatles.members.remove(ringo)

>>> # Beatles have broken up
>>> beatles.members.clear()
>>> # Note that this deletes the intermediate model instances
>>> Membership.objects.all()
<QuerySet []>

# Find all the groups with a member whose name starts with 'Paul'
>>> Group.objects.filter(members__name__startswith='Paul')
<QuerySet [<Group: The Beatles>]>


# Find all the members of the Beatles that joined after 1 Jan 1961
>>> Person.objects.filter(
...     group__name='The Beatles',
...     membership__date_joined__gt=date(1961,1,1))
<QuerySet [<Person: Ringo Starr]>

```

​	使用中间对象建立的多对多，在建立关系时，必须使用中间对象。查找时可以使用关联的属性。

[many-to-many reverse relationship](https://docs.djangoproject.com/en/1.11/topics/db/queries/#m2m-reverse-relationships) 

##### 一对一关系

​	使用   [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) 来定义。特别适用于对象扩展对象的主键。

​	[One-to-one relationship model example](https://docs.djangoproject.com/en/1.11/topics/db/examples/one_to_one/) 

​	对于外键，可以定义[recursive relationship](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和 [references to as-yetundefined models](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships) 。

​	OneToOneField 可以接受  [`parent_link`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField.parent_link)  参数。

> [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) classes used to automatically become the primary key on a model. This is no longer true (although you can manually pass in the [`primary_key`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.primary_key) argument if you like). Thus, it’s now possible to have multiple fields of type[`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) on a single model.

#### 跨文件模型

​	只需导入相应文件即可

```python
from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
    # ...
    zip_code = models.ForeignKey(
        ZipCode,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )
```

#### 字段名称限制

​	Django对于字段名称有两个限制：

- 字段名称不能是python 的保留字段，因为会影响 python 解析
- 字段名称不能包含两个以上的下划线 ，因为会影响 Django 的查询语法

#### 自定义字段类型

​	详见[Writing custom model fields](https://docs.djangoproject.com/en/1.11/howto/custom-model-fields/).

### 2.1.4 meta options

​	通过使用 内部类 Meta：

```python
from django.db import models

class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"
```

> Model metadata is “anything that’s not a field”, such as ordering options
> ([`ordering`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.ordering)), database table name ([`db_table`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.db_table)), or
> human-readable singular and plural names ([`verbose_name`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.verbose_name) and
> [`verbose_name_plural`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.verbose_name_plural)). None are required, and adding `class
> Meta` to a model is completely optional.

​	详见[model option reference](https://docs.djangoproject.com/en/1.11/ref/models/options/).

### 2.1.5 模型属性

objects

​	模型最重要的属性是   [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) ，用于数据的操作。如果没有指定，默认为 [`objects`](https://docs.djangoproject.com/en/1.11/ref/models/class/#django.db.models.Model.objects)。 而且只能通过类访问。

### 2.1.6 模型方法

​	自定义模型方法添加了“row-level” 功能。 [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) methods are intended to do “table-wide” things

例如：

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        "Returns the person's full name."
        return '%s %s' % (self.first_name, self.last_name)
```

​	[methods automatically given to each model](https://docs.djangoproject.com/en/1.11/ref/models/instances/#model-instance-methods). [overriding predefined model methods](https://docs.djangoproject.com/en/1.11/topics/db/models/#overriding-predefined-model-methods),

#### 重写预定义的模型方法

​	例如：

```python
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        do_something()
        super(Blog, self).save(*args, **kwargs) # Call the "real" save() method.
        do_something_else()
```

#### 执行自定义SQL

​	[using raw SQL](https://docs.djangoproject.com/en/1.11/topics/db/sql/).

### 2.1.7 模型继承

​	与普通的python 类继承一致。

​	你需要确定父模型是否需要建立数据库表，或父模型拥有只能通过子模型访问的共有信息。

​	在 Django 中共拥有三种类型的继承：

- 使用父模型保存共有信息，[Abstract base classes](https://docs.djangoproject.com/en/1.11/topics/db/models/#abstract-base-classes) 最适合
- 如果创建一个模型的子模型，并且想让每个模型都有自己的数据库表，[Multi-table inheritance](https://docs.djangoproject.com/en/1.11/topics/db/models/#multi-table-inheritance) 最合适
- 如果只想修改模型的行为，[Proxy models](https://docs.djangoproject.com/en/1.11/topics/db/models/#proxy-models) 最合适

#### 抽象基类

​	写基类时，把 abstract=True 放入 Meta 中。这种方式基类不会生成数据库的表。基类的字段会添加到子类中。django 中不允许抽象基类中的字段与子类相同。

```python
from django.db import models

class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True

class Student(CommonInfo):
    home_group = models.CharField(max_length=5)
```

##### 元继承

​	如果子类中没有自己的 Meta 类，会继承父类的。如果想扩展父类的 Meta类，可以从它来继承。

```python
from django.db import models

class CommonInfo(models.Model):
    # ...
    class Meta:
        abstract = True
        ordering = ['name']

class Student(CommonInfo):
    # ...
    class Meta(CommonInfo.Meta):
        db_table = 'student_info'
```

​	Django 会对抽象基类中的 Meta 会做调整，（abstract = False）

##### 小心使用 related_name 和 related_query_name

​	如果  在  `ForeignKey` 或`ManyToManyField` 中使用 [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) 或[`related_query_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_query_name)  ，必须指定唯一反向字段。在抽象类中，会发生问题（包含在这所有子类中）。

​	为避免，在抽象基类中使用   [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) or
[`related_query_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_query_name) ，部分值必须包含`'%(app_label)s'` and
`'%(class)s'`. 

- `'%(class)s'` 会替换为小写的子类名
- `'%(app_label)s'`会替换为小写的子类所在app 名



app `common/models.py`:

```python
from django.db import models

class Base(models.Model):
    m2m = models.ManyToManyField(
        OtherModel,
        related_name="%(app_label)s_%(class)s_related",
        related_query_name="%(app_label)s_%(class)ss",
    )

    class Meta:
        abstract = True

class ChildA(Base):
    pass

class ChildB(Base):
    pass
```

app `rare/models.py`:

```python
from common.models import Base

class ChildB(Base):
    pass
```

> The reverse name of the `common.ChildA.m2m` field will be
> `common_childa_related` and the reverse query name will be `common_childas`.

如果没有指定    [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) 时，默认使用 XX（小写类名）_set

#### 多表继承

​	多层次模型，每个模型都有对应的数据库。子模型和父模型通过自动添加的 （[`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField)）(在子类中) 建立关系。

```python
from django.db import models

class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

class Restaurant(Place):
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)
```

​	如果一个 Place 也是 Restaurant，那么就可以得到 Restaurant

```
>>> p = Place.objects.get(id=12)
# If p is a Restaurant object, this will give the child class:
>>> p.restaurant
<Restaurant: ...>
```

​	自动添加在子类的关系如下：

```python
place_ptr = models.OneToOneField(
    Place, on_delete=models.CASCADE,
    parent_link=True,
)
```

##### 元和多表继承

​	元表已经用于父类，如果再用于子类，会导致矛盾行为

```python
class ChildModel(ParentModel):
    # ...
    class Meta:
        # Remove parent's ordering effect
        ordering = []
```

##### 继承与颠倒关系

​	由于存在   [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) ，可以从父移动到子。

​	在如果想  在[`ManyToManyField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField) 中使用，必须指定[`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) 。

```
class Supplier(Place):
    customers = models.ManyToManyField(Place, related_name='provider').
```

##### 指定父连接字段

​	如果想控制连接到父类的名称，可以自己创建 [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField)  并指定 [`parent_link=True`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField.parent_link) 。

#### 代理模型

​	将 Meta 类的 proxy 属性设置为 True

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

class MyPerson(Person):
    class Meta:
        proxy = True

    def do_something(self):
        # ...
        pass
```

```
>>> p = Person.objects.create(first_name="foobar")
>>> MyPerson.objects.get(first_name="foobar")
<MyPerson: foobar>
```

​	也可以通过代理改变排序

```python
class OrderedPerson(Person):
    class Meta:
        ordering = ["last_name"]
        proxy = True
```

##### QuerySets 仍然返回相关的模型

​	Django 并不会返回代理类，代理类并不能代替原类。

##### 基础类限制

​	只能继承一个非抽象的类。可以继承多个抽象类。也可以从多个代理类继承（共享非抽象父类）

##### 代理模型管理

​	如果没有为定代理模型指定管理模型，则会继承父模型的。

```python
from django.db import models

class NewManager(models.Manager):
    # ...
    pass

class MyPerson(Person):
    objects = NewManager()		# 成为默认，也可访问父类的

    class Meta:
        proxy = True
```

​	如果想给代理添加新管理（不替换默认的），可以使用[custom manager](https://docs.djangoproject.com/en/1.11/topics/db/managers/#custom-managers-and-inheritance)  技术：创建包含管理的基类，然后继承

```python
# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
    secondary = NewManager()

    class Meta:
        abstract = True

class MyPerson(Person, ExtraManagers):
    class Meta:
        proxy = True
```

##### 代理继承与无管理模型的差异

> 1. If you are mirroring an existing model or database table and don’t wantall the original database table columns, use `Meta.managed=False`.That option is normally useful for modeling database views and tablesnot under the control of Django.
> 2. If you are wanting to change the Python-only behavior of a model, butkeep all the same fields as in the original, use `Meta.proxy=True`.This sets things up so that the proxy model is an exact copy of thestorage structure of the original model when data is saved.

#### 多继承

> Keep in mind that normal Python name resolution rules apply.

​	如只有第一个的Meta 起作用。

​	多继承用于 “mix-in”类：去增加一个字段或方法。在多继承中需在基类中显示使用 [`AutoField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.AutoField) 字段，否则因默认的 ”id“ 会引起异常。也可以使用 共同的 祖先。

```python
class Article(models.Model):
    article_id = models.AutoField(primary_key=True)
    #...

class Book(models.Model):
    book_id = models.AutoField(primary_key=True)
    #...

class BookReview(Book, Article):
    pass
```

```python
class Piece(models.Model):
    pass

class Article(Piece):
   # ...

class Book(Piece):
   # ...

class BookReview(Book, Article):
    pass
```

#### 不许使用“hiding”字段

​	在一般类继承中，允许子类覆盖父类的属性。 但在 Django 中通常是不允许的。对于抽象基类并不适用。	

### 2.1.8 在包中组织模型

​	创建 models 目录（包含`__init__`.py）\

```python
#myapp/models/__init__.py
# 在 models 目录下有 organic.py 和 synthetic.py
from .organic import Person
from .synthetic import Robot
```

​	

## 2.2 查询

```python
# 使用示例
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Entry(models.Model):
    blog = models.ForeignKey(Blog)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    authors = models.ManyToManyField(Author)
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self):              # __unicode__ on Python 2
        return self.headline
```

### 2.2.1 创建对象

```shell
>>> from blog.models import Blog
>>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
>>> b.save()
```

​	当调用  [`save()`](https://docs.djangoproject.com/en/1.11/ref/models/instances/#django.db.models.Model.save) 方法时，才去数据库操作。 [`save()`](https://docs.djangoproject.com/en/1.11/ref/models/instances/#django.db.models.Model.save) 没有返回值。

​	如果想一步创建保存对象，可以使用 [`create()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.create) 

### 2.2.2 将改变保存到对象

```shell
>>> b5.name = 'New name'
>>> b5.save()
```

#### 保存外键和 ManyToManyField

外键：

```python
>>> from blog.models import Blog, Entry	# 当做普通对象
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()
```

ManyToMany:

```python
>>> from blog.models import Author		# 使用 add 方法
>>> joe = Author.objects.create(name="Joe")
>>> entry.authors.add(joe)

>>> john = Author.objects.create(name="John")	# 一次添加多个
>>> paul = Author.objects.create(name="Paul")
>>> george = Author.objects.create(name="George")
>>> ringo = Author.objects.create(name="Ringo")
>>> entry.authors.add(john, paul, george, ringo)
```

### 2.2.3 获取对象

​	通过 [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager)  构造 [`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) 。[`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) 代表从数据库取到的集合。每个模型至少有一个  [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) 即，[`objects`](https://docs.djangoproject.com/en/1.11/ref/models/class/#django.db.models.Model.objects) ，使用模型来访问

```python
>>> Blog.objects
<django.db.models.manager.Manager object at ...>
>>> b = Blog(name='Foo', tagline='Bar')
>>> b.objects
Traceback:
    ...
AttributeError: "Manager isn't accessible via Blog instances."
```

#### 获取所有

```python
>>> all_entries = Entry.objects.all()
```

#### 使用filter获取指定对象

`filter(**kwargs)` 返回满足条件的

`exclude(**kwargs)` 返回不满足条件的

参数的格式满足：[Field lookups](https://docs.djangoproject.com/en/1.11/topics/db/queries/#field-lookups) 

##### filter 链

QuerySet 查询的记过还是 QuerySet，因此可以链起来。

```python
>>> Entry.objects.filter(
...     headline__startswith='What'
... ).exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(
...     pub_date__gte=datetime(2005, 1, 30)
... )
```

##### 过滤的 QuerySets 是唯一的

```python
>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today())
```

​	这些QuerySet 是独立的。

##### QuerySets 是延时的

​	直到用到数据时才会去数据库操作。

#### 使用 get（）获取单个对象

​	如果确定结果只有一个，使用 get（） 直接返回。

​	如果没有找到 会抛出 `Entry.DoesNotExist`.

​	如果get（） 返回多个值，会抛出[`MultipleObjectsReturned`](https://docs.djangoproject.com/en/1.11/ref/exceptions/#django.core.exceptions.MultipleObjectsReturned), 

#### 其他 QuerySet 方法

​	[QuerySet API Reference](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#queryset-api) 

#### 限制 QuerySet

​	使用 python 的切片语法。可以达到与 SQL的 LIMIT 和OFFSET 相同的效果。

```python
>>> Entry.objects.all()[:5]        # (LIMIT 5):   返回 QuerySet
>>> Entry.objects.all()[5:10]		# (OFFSET 5 LIMIT 5): 返回 QuerySet

###  不支持负索引

>>> Entry.objects.all()[:10:2]		# 返回 List

>>> Entry.objects.order_by('headline')[0] #SELECT foo FROM bar LIMIT 1
# 等价于
>>> Entry.objects.order_by('headline')[0:1].get()

```

#### 字段查找

​	相当于 SQL 的 WHERE。格式`field__lookuptype=value`.

```python
>>> Entry.objects.filter(pub_date__lte='2006-01-01')		
```

对应 SQL语句：

```sql
SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';
```

​	这种方式归功于 python可以接受任意键值对，作为参数（在运行时确定值） [Keyword Arguments](https://docs.python.org/3/tutorial/controlflow.html#tut-keywordargs)

​	查询的字段必须为模型的字段。有一种情况例外，在外键中使用 field_id.

```python
>>> Entry.objects.filter(blog_id=4)
```

​	查询类型参考： [field lookup reference](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#field-lookups).

```python
>>> Blog.objects.get(id__exact=14)  # Explicit form
>>> Blog.objects.get(id=14)         # __exact is implied
```

#### 多表查询

​	使用相关联模型的字段

```python
>>> Entry.objects.filter(blog__name='Beatles Blog')
```

​	反向查询时，小写 模型名：

```python
>>> Blog.objects.filter(entry__headline__contains='Lennon')
```

​	如果跨越多表，但是中间模型没有满足条件，Django 会它当做空值，而不是抛出异常：

```python
Blog.objects.filter(entry__authors__name='Lennon')
```

如果 没有 author 与 entry 关联，也就没有与 name 关联。

```python
Blog.objects.filter(entry__authors__name__isnull=True)
```

会返回name 为空，与entry 相关 author 为空的 blog。

如果不想要author 为：

```python
Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)
```

##### 跨越多值关系  ^-^

```python
Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)		# 同时 (the same entry satisfying both conditions) 在多值关系中用于同一个
Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)		# 在多值关系中用于多个
```

> Everything inside a single [`filter()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter) call is applied simultaneously to filter out items matching all those requirements. 
>
> Successive [`filter()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter) calls further restrict the set of objects, but for multi-valued relations, they apply to any object linked to the primary model, not necessarily those objects that were selected by an earlier [`filter()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter) call.

Suppose there is only one blog that had both entries containing *“Lennon”* and
entries from 2008, but that none of the entries from 2008 contained *“Lennon”*.
The first query would not return any blogs, but the second query would return
that one blog.

 注意：

exclude 与 filter不同，条件不是同时满足

```python
Blog.objects.exclude(
    entry__headline__contains='Lennon',
    entry__pub_date__year=2008,
)# 达不到效果 应使用下面的：
Blog.objects.exclude(
    entry__in=Entry.objects.filter(
        headline__contains='Lennon',
        pub_date__year=2008,
    ),
)
```

#### 使用模型上的字段进行过滤

​	不同字段的比较，使用 [`F expressions`](https://docs.djangoproject.com/en/1.11/ref/models/expressions/#django.db.models.F) 

```python
>>> from django.db.models import F
>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
```

> Django supports the use of addition, subtraction, multiplication, division, modulo, and power arithmetic with `F()` objects, both with constants and with other `F()` objects.

​	在 F 表达式中也可以使用 __ 进行关系扩展。

```python
>>> Entry.objects.filter(authors__name=F('blog__name'))
```

​	在 F 表达式中也可以与 [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) 进行运算 （针对于时间）

```python
>>> from datetime import timedelta
>>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))
```

​	在 F 表达式中也可以进行位运算： `.bitand()`, `.bitor()`,
`.bitrightshift()`, and `.bitleftshift()`.

```python
>>> F('somefield').bitand(16)
```

#### 主键的快捷查找

​	Django 提供了  **pk**

```python
>>> Blog.objects.get(id__exact=14) # Explicit form
>>> Blog.objects.get(id=14) # __exact is implied
>>> Blog.objects.get(pk=14) # pk implies id__exact
```

```python
>>> Entry.objects.filter(blog__id__exact=3) # Explicit form
>>> Entry.objects.filter(blog__id=3)        # __exact is implied
>>> Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact		# 跨关系
```

#### 在 LIKE 语句中转义 百分号 下划线

​	自动转义（针对使用对象的查询）

```python
>>> Entry.objects.filter(headline__contains='%')	# 包含百分号的
```

​	对应SQL：

```SQL
SELECT ... WHERE headline LIKE '%\%%';
```

#### 缓存与 QuerySet

​	每个QuerySet 包含一个缓存以最小访问数据库。

```python
>>> print([e.headline for e in Entry.objects.all()])
>>> print([e.pub_date for e in Entry.objects.all()])
#	两次访问数据库，两次缓存，使用后丢弃

>>> queryset = Entry.objects.all()
>>> print([p.headline for p in queryset]) # Evaluate the query set.
>>> print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.
```

##### 不缓存QuerySet的情形

​	当对 QuerySet 的部分求值时

```python
>>> queryset = Entry.objects.all()
>>> print(queryset[5]) # Queries the database
>>> print(queryset[5]) # Queries the database again
```

```python
>>> queryset = Entry.objects.all()
>>> [entry for entry in queryset] # Queries the database
>>> print(queryset[5]) # Uses cache
>>> print(queryset[5]) # Uses cache
```

### 2.2. 4 用 Q 对象进行复杂查询

[`Q object`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.Q) (`django.db.models.Q`) 封装了查询条件（关键字参数）。

Q对象 可以使用 & 、| 和 ~ 进行联合，产生一个新的 Q对象

```python
Poll.objects.get(
    Q(question__startswith='Who'),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
```

等价于 SQL

```sql
SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')
```

​	Q 对象也可以与 关键字参数结合。但是Q 对象必须在前：

```python
Poll.objects.get(
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
    question__startswith='Who',
)


# INVALID QUERY
Poll.objects.get(
    question__startswith='Who',
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
```

​	[OR lookups examples](https://github.com/django/django/blob/master/tests/or_lookups/tests.py)

### 2.2.5 对象比较

​	两个模型实例的比较，只需使用标准的 python 比较运算。（==）比较主键：

```python
# 下面是等价的
>>> some_entry == other_entry
>>> some_entry.id == other_entry.id
```

### 2.2.6 删除对象

​	[`delete()`](https://docs.djangoproject.com/en/1.11/ref/models/instances/#django.db.models.Model.delete) 返回删除的数目，以及字典（包含删除的类型和数目）

```python
>>> e.delete()
(1, {'weblog.Entry': 1})

>>> Entry.objects.filter(pub_date__year=2005).delete()
(5, {'webapp.Entry': 5})
```

​	**记住：上面的作为纯SQL 执行，所以每个对象的 delete() 方法不会被调用。**

​	**如果我们提供一个 自定义的 delete()， 我们需要手动的调用每一个对象的 delete()**

> Note that [`delete()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.delete) is the only [`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) method that is not exposed on a [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) itself. 避免了意外全删   

### 2.2.7 复制模型实例

​	把 **pk** 设为**None**

```python
blog = Blog(name='My blog', tagline='Blogging is easy')
blog.save() # blog.pk == 1

blog.pk = None
blog.save() # blog.pk == 2
```

​	对于继承：

```python
class ThemeBlog(Blog):
    theme = models.CharField(max_length=200)

django_blog = ThemeBlog(name='Django', tagline='Django is easy', theme='python')
django_blog.save() # django_blog.pk == 3
```

```python
django_blog.pk = None
django_blog.id = None
django_blog.save() # django_blog.pk == 4
```

​	对于多对多，必须手动设置关系

```python
entry = Entry.objects.all()[0] # some previous entry
old_authors = entry.authors.all()
entry.pk = None
entry.save()
entry.authors.set(old_authors)  # 只设置了新 entry
```

​	对于一对一，必须复制相关对象，并赋值给新的对象属性，以满足限制条件。假设已经复制了 entry

```python
detail = EntryDetail.objects.all()[0]
detail.pk = None
detail.entry = entry
detail.save()
```

### 2.2.8 一次更新多个对象

```python
# Update all the headlines with pub_date in 2007.
Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')
```

```python
>>> b = Blog.objects.get(pk=1)

# Change every Entry so that it belongs to this Blog.
>>> Entry.objects.all().update(blog=b)	
```

​	update() 返回相匹配的行（可能不等于更新的行）。**唯一的限制就是只能访问一个数据库表：模型的主表**

```
>>> b = Blog.objects.get(pk=1)

# Update all the headlines belonging to this Blog.
>>> Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same')
```

​	**作为直接转化为SQL 的 update() 方法。作为批直接更新。不会调用 模型的 save()方法，忽略 pre_save 和 post_save 信号，honor the**
**[`auto_now`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.DateField.auto_now) field option。 如果想确保 QuerySet 中的每一个实例都调用 save() 方法保存，只需循环遍历调用。**

```python
for item in my_queryset:
    item.save()
```

​	F 表达式也同样适用。

```python
>>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)
```

​	但是不能操作其他表

```python
# This will raise a FieldError
>>> Entry.objects.update(headline=F('blog__name'))
```

### 2.2.9 相关联的对象

​	定义了模型之间的关系，模型实例有方便访问相关对象的API

#### one-to-many关系

##### 正向

​	定义关系的模型，直接使用属性访问。

```python
>>> e = Entry.objects.get(id=2)
>>> e.blog # Returns the related Blog object.
```

```python
>>> e = Entry.objects.get(id=2)
>>> e.blog = some_blog
>>> e.save()	# 更改之后需要 save() 才能保存到数据库
```

​	如果 外键 设置了 null= True， 可以直接设为 None，移除关系：

```python
>>> e = Entry.objects.get(id=2)
>>> e.blog = None
>>> e.save() # "UPDATE blog_entry SET blog_id = NULL ...;"
```

```python
>>> e = Entry.objects.get(id=2)		# 缓存了
>>> print(e.blog)  # Hits the database to retrieve the associated Blog.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
```

> Note that the [`select_related()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.select_related) [`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) method recursively prepopulates the cache of all one-to-many relationships ahead of time. Example:

```python
>>> e = Entry.objects.select_related().get(id=2)
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
```

##### 反向

​	相关联的模型，Manager 有 XX_set()

```python
>>> b = Blog.objects.get(id=1)
>>> b.entry_set.all() # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
>>> b.entry_set.filter(headline__contains='Lennon')
>>> b.entry_set.count()
```

​	也可以覆盖上面的访问名称，但是需要在定义的时候就指定 **blog = ForeignKey(Blog, on_delete=models.CASCADE,**
**related_name='entries')**

即：

```python
>>> b = Blog.objects.get(id=1)
>>> b.entries.all() # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns QuerySets.
>>> b.entries.filter(headline__contains='Lennon')
>>> b.entries.count()
```

##### 使用自定义的反向 manager

 subclass of the [default manager](https://docs.djangoproject.com/en/1.11/topics/db/managers/#manager-names)

```python
from django.db import models

class Entry(models.Model):
    #...
    objects = models.Manager()  # Default Manager
    entries = EntryManager()    # Custom Manager  

b = Blog.objects.get(id=1)
b.entry_set(manager='entries').all()	# 如果实现 get_queryset() 
```

###### 其他处理相关对象的方法：

​	the [`ForeignKey`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey) [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) has additional methods used to handle the
set of related objects。

`add(obj1, obj2, ...)`

`create(**kwargs)`：

`remove(obj1, obj2, ...)`

`clear()`

`set(objs)`

```python
b = Blog.objects.get(id=1)
b.entry_set.set([e1, e2])
```

#### many-to-many 关系

​	正向使用： 属性名

​	反向使用 ： 小写模型名_set

```python
e = Entry.objects.get(id=3)
e.authors.all() # Returns all Author objects for this Entry.
e.authors.count()
e.authors.filter(name__contains='John')

a = Author.objects.get(id=5)
a.entry_set.all() # Returns all Entry objects for this Author.
```

​	当然也可以指定 [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.related_name).

#### one-to-one 关系

```python
class EntryDetail(models.Model):
    entry = models.OneToOneField(Entry, on_delete=models.CASCADE)
    details = models.TextField()

ed = EntryDetail.objects.get(id=2)
ed.entry # Returns the related Entry object. 使用属性
```

​	反向使用：（访问[`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager)  ，但是只有一个 对象）

```python
e = Entry.objects.get(id=2)
e.entrydetail # returns the related EntryDetail object
```

#### 反向关系如何实现

​	其他 ORM需要 双边定义，Django 开发者认为这违反了 DRY（Don’t
Repeat Yourself），因一边进行定义。

​	 [`app registry`](https://docs.djangoproject.com/en/1.11/ref/applications/#django.apps.apps).使其成为可能。在导入时添加了关系。

#### 通过关联对象查询

​	如果 blog 对象的 id =5 

```python
Entry.objects.filter(blog=b) # Query using object instance
Entry.objects.filter(blog=b.id) # Query using id from instance
Entry.objects.filter(blog=5) # Query using id directly
```

### 2.2.10 使用原始 SQL

​	[Performing raw SQL queries](https://docs.djangoproject.com/en/1.11/topics/db/sql/).	

## 2.3 聚集（*aggregation*）

​	使用模型

```python
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()

class Publisher(models.Model):
    name = models.CharField(max_length=300)
    num_awards = models.IntegerField()

class Book(models.Model):
    name = models.CharField(max_length=300)
    pages = models.IntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    rating = models.FloatField()
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    pubdate = models.DateField()

class Store(models.Model):
    name = models.CharField(max_length=300)
    books = models.ManyToManyField(Book)
    registered_users = models.PositiveIntegerField()
```

### 2.3.1 简单说明

```python
# Total number of books.
>>> Book.objects.count()
2452

# Total number of books with publisher=BaloneyPress
>>> Book.objects.filter(publisher__name='BaloneyPress').count()
73

# Average price across all books.
>>> from django.db.models import Avg
>>> Book.objects.all().aggregate(Avg('price'))
{'price__avg': 34.35}

# Max price across all books.
>>> from django.db.models import Max
>>> Book.objects.all().aggregate(Max('price'))
{'price__max': Decimal('81.20')}

# Difference between the highest priced book and the average price of all books.
>>> from django.db.models import FloatField
>>> Book.objects.aggregate(
...     price_diff=Max('price', output_field=FloatField()) - Avg('price')))
{'price_diff': 46.85}

# All the following queries involve traversing the Book<->Publisher
# foreign key relationship backwards.

# Each publisher, each with a count of books as a "num_books" attribute.
>>> from django.db.models import Count
>>> pubs = Publisher.objects.annotate(num_books=Count('book'))
>>> pubs
<QuerySet [<Publisher: BaloneyPress>, <Publisher: SalamiPress>, ...]>
>>> pubs[0].num_books
73

# The top 5 publishers, in order by number of books.
>>> pubs = Publisher.objects.annotate(num_books=Count('book')).order_by('-num_books')[:5]
>>> pubs[0].num_books
1323
```

### 2.3.2  QuerySet 上的聚集

​	QuerySet 整体上 产生聚集：

```python
>>> from django.db.models import Avg
>>> Book.objects.all().aggregate(Avg('price'))
{'price__avg': 34.35}		

# 也可以不使用 all()
>>> Book.objects.aggregate(Avg('price'))
{'price__avg': 34.35}
```

​	可用的聚集函数 [QuerySet reference](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#aggregation-functions).

​	`aggregate()` 会终止 QuerySet ，返回字典{聚集的标识（属性和聚集函数生成）：计算的值}。如果想指定名称，在聚集语句中指定名称：

```python
>>> Book.objects.aggregate(average_price=Avg('price'))
{'average_price': 34.35}
```

​	如果想产生多个聚集，只需将参数加入 `aggregate()` ：

```python
>>> from django.db.models import Avg, Max, Min
>>> Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))
{'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')
```

### 2.3.3 QuerySet 每项的聚集

​	使用`annotate()` 语句，语法与`aggregate()` 相同。

```python
# Build an annotated queryset
>>> from django.db.models import Count
>>> q = Book.objects.annotate(Count('authors'))
# Interrogate the first object in the queryset
>>> q[0]
<Book: The Definitive Guide to Django>
>>> q[0].authors__count
2
# Interrogate the second object in the queryset
>>> q[1]
<Book: Practical Django Projects>
>>> q[1].authors__count
1
```

​	与 `aggregate()`不同的是，`annotate()` 的返回值仍然是 QuerySet。

#### 多个聚集联合？？？

​	在 `annotate()` 中使用多个聚合，由于使用联合，而不是子查询，因此会导致错误：

```python
>>> book = Book.objects.first()
>>> book.authors.count()
2
>>> book.store_set.count()
3
>>> q = Book.objects.annotate(Count('authors'), Count('store'))
>>> q[0].authors__count
6
>>> q[0].store__count
6
```

​	对于一般的聚合没法颁发避免，但是对于 Count 聚合，可以使用 `distinct`参数：

```python
>>> q = Book.objects.annotate(Count('authors', distinct=True), Count('store', distinct=True))
>>> q[0].authors__count
2
>>> q[0].store__count
3
```

### 2.3.4 联合与聚集

​	在聚合中可以使用` __` 来引用相关联的字段。Django会处理表的联合。 

​	`annotate()` 和`aggregate()` 都适用。

```python
>>> from django.db.models import Max, Min
>>> Store.objects.annotate(min_price=Min('books__price'), max_price=Max('books__price'))
 
    
>>> Store.objects.aggregate(min_price=Min('books__price'), max_price=Max('books__price'))


>>> Store.objects.aggregate(youngest_age=Min('books__authors__age'))	# 可以任意深度
```

#### 反向关系

​	使用相关对象的小写：

​	`Publisher` -> `Book` reverse foreign key 

​	`Author` -> `Book` reverse many-to-many 

```python
>>> from django.db.models import Count, Min, Sum, Avg
>>> Publisher.objects.annotate(Count('book'))

>>> Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))


>>> Author.objects.annotate(total_pages=Sum('book__pages'))
```

### 2.3.5 聚集和其他 QuerySet 语句

#### filter()  和 exclude()

​	用于聚合 filter() 和 exclude() 的结果：

```python
>>> from django.db.models import Count, Avg
>>> Book.objects.filter(name__startswith="Django").annotate(num_authors=Count('authors'))

>>> Book.objects.filter(name__startswith="Django").aggregate(Avg('price'))
```

##### annotate 过滤

```python
>>> Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)		# 启的别名与 字段一样使用
```

##### annotate()  和 filter() 语句的顺序

Given:

- Publisher A has two books with ratings 4 and 5.
- Publisher B has two books with ratings 1 and 4.
- Publisher C has one book with rating 1.

```python
>>> a, b = Publisher.objects.annotate(num_books=Count('book', distinct=True)).filter(book__rating__gt=3.0)
>>> a, a.num_books
(<Publisher: A>, 2)
>>> b, b.num_books
(<Publisher: B>, 2)

>>> a, b = Publisher.objects.filter(book__rating__gt=3.0).annotate(num_books=Count('book'))
>>> a, a.num_books
(<Publisher: A>, 2)
>>> b, b.num_books
(<Publisher: B>, 1)
```

```python
>>> a, b = Publisher.objects.annotate(avg_rating=Avg('book__rating')).filter(book__rating__gt=3.0)
>>> a, a.avg_rating
(<Publisher: A>, 4.5)  # (5+4)/2
>>> b, b.avg_rating
(<Publisher: B>, 2.5)  # (1+4)/2

>>> a, b = Publisher.objects.filter(book__rating__gt=3.0).annotate(avg_rating=Avg('book__rating'))
>>> a, a.avg_rating
(<Publisher: A>, 4.5)  # (5+4)/2
>>> b, b.avg_rating
(<Publisher: B>, 4.0)  # 4/1 (book with rating 1 excluded)
```

#### order_by()

```python
>>> Book.objects.annotate(num_authors=Count('authors')).order_by('num_authors')
```

#### values()

> the original results are grouped according to the unique combinations of the fields specified in the`values()` clause. An annotation is then provided for each unique group; the annotation is computed over all members of the group.

```python
>>> Author.objects.annotate(average_rating=Avg('book__rating'))

>>> Author.objects.values('name').annotate(average_rating=Avg('book__rating')) #This means if you have two authors with the same name, their results will be merged into a single result in the output of the query; the average will be computed as the average over the books written by both authors.
```

##### annotate()  和 values() 语句的顺序

```python
>>> Author.objects.annotate(average_rating=Avg('book__rating')).values('name', 'average_rating')# This will now yield one unique result for each author; however, only the author’s name and the average_rating annotation will be returned in the output data.
```

> If the `values()` clause precedes the `annotate()` clause, any annotations will be automatically added to the result set. However, if the `values()` clause is applied after the `annotate()` clause, you need to explicitly include the aggregate column. values() 在后需手动添加。

##### 与默认排序或order_by() 的交互

```python
from django.db import models

class Item(models.Model):
    name = models.CharField(max_length=10)
    data = models.IntegerField()

    class Meta:
        ordering = ["name"]
        

        
# Warning: not quite correct!
Item.objects.values("data").annotate(Count("id"))
# group the Item objects by their common data values and then count the number of id values in each group. this query will group by distinct (data, name) 


Item.objects.values("data").annotate(Count("id")).order_by()
# clearing any ordering in the query，
```

> You might reasonably ask why Django doesn’t remove the extraneous columns for you. The main reason is consistency with `distinct()` and other places: Django **never** removes ordering constraints that you have specified (and we can’t change those other methods’ behavior, as that would violate our [API stability](https://docs.djangoproject.com/en/1.11/misc/api-stability/) policy).

#### `aggregate`（）和  `annotate()` 连接

```python
>>> from django.db.models import Count, Avg
>>> Book.objects.annotate(num_authors=Count('authors')).aggregate(Avg('num_authors'))
{'num_authors__avg': 1.66}
```

## 2.4 搜索

### 2.4.1 用例

#### 标准文本查询

```python
>>> Author.objects.filter(name__contains='Terry')
[<Author: Terry Gilliam>, <Author: Terry Jones>]
```

#### 数据库的高级比较函数

​	Django 针对 PostgreSQL，提供了 [a selection of database specific tools](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/) 。

​	[`unaccented comparison`](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/lookups/#std:fieldlookup-unaccent):

```python
>>> Author.objects.filter(name__unaccent__icontains='Helen')
[<Author: Helen Mirren>, <Author: Helena Bonham Carter>, <Author: Hélène Joy>]
```

​	[`trigram_similar`](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/lookups/#std:fieldlookup-trigram_similar) 

```python
>>> Author.objects.filter(name__unaccent__lower__trigram_similar='Hélène')
[<Author: Helen Mirren>, <Author: Hélène Joy>]
```

#### 基于文档的搜索

some of the most prominent are [Elastic](https://www.elastic.co/) and [Solr](http://lucene.apache.org/solr/).

- Ignoring “stop words” such as “a”, “the”, “and”.
- Stemming words, so that “pony” and “ponies” are considered similar.
- Weighting words based on different criteria such as how frequently theyappear in the text, or the importance of the fields, such as the title orkeywords, that they appear in.

##### PostgreSQL 的支持

​	[`django.contrib.postgres`](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/#module-django.contrib.postgres)    [Full text search](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/)  

```python
>>> Entry.objects.filter(body_text__search='cheese') # 搜索 提到cheese
[<Entry: Cheese on Toast recipes>, <Entry: Pizza recipes>]
```

## 2.5 Managers

​	class `Manager`[[source\]](https://docs.djangoproject.com/en/1.11/_modules/django/db/models/manager/#Manager)[¶](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) 是进行数据库查询的接口，Django应用的 模型至少存在一个。

### 2.5.1 Manager的名称

​	默认会在每个Django 模型类添加名为 `objects` 的`Manager` 。如果想将 `objects` 作为字段名，或者使用其他名字的 `Manager`，我们需要定义一个  `models.Manager()` 类型的属性：

```python
from django.db import models

class Person(models.Model):
    #...
    people = models.Manager()
```

​	Using this example model, `Person.objects` will generate an
`AttributeError` exception,

### 2.5.2 自定义管理类

​	扩展 `Manager` , 在模型中自己实例化。

#### 添加额外的管理方法

​	添加表级的功能。可以返回我们想要的，不必返回 QuerySet。

```python
from django.db import models

class PollManager(models.Manager):
    def with_counts(self):
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT p.id, p.question, p.poll_date, COUNT(*)
                FROM polls_opinionpoll p, polls_response r
                WHERE p.id = r.poll_id
                GROUP BY p.id, p.question, p.poll_date
                ORDER BY p.poll_date DESC""")
            result_list = []
            for row in cursor.fetchall():
                p = self.model(id=row[0], question=row[1], poll_date=row[2])
                p.num_responses = row[3]
                result_list.append(p)
        return result_list

class OpinionPoll(models.Model):
    question = models.CharField(max_length=200)
    poll_date = models.DateField()
    objects = PollManager()

class Response(models.Model):
    poll = models.ForeignKey(OpinionPoll, on_delete=models.CASCADE)
    person_name = models.CharField(max_length=50)
    response = models.TextField()
```

`OpinionPoll.objects.with_counts()`  return
that list of `OpinionPoll` objects with `num_responses` attributes.

​	self.mode 可以获得相关联的模型类。

#### 修改Manager的初始化QuerySet

​	覆盖`Manager.get_queryset()` 方法：

```python
# First, define the Manager subclass.
class DahlBookManager(models.Manager):
    def get_queryset(self):
        return super(DahlBookManager, self).get_queryset().filter(author='Roald Dahl')

# Then hook it into the Book model explicitly.
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=50)

    objects = models.Manager() # The default manager.
    dahl_objects = DahlBookManager() # The Dahl-specific manager.
```

```python
class AuthorManager(models.Manager):
    def get_queryset(self):
        return super(AuthorManager, self).get_queryset().filter(role='A')

class EditorManager(models.Manager):
    def get_queryset(self):
        return super(EditorManager, self).get_queryset().filter(role='E')

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    role = models.CharField(max_length=1, choices=(('A', _('Author')), ('E', _('Editor'))))
    people = models.Manager()
    authors = AuthorManager()
    editors = EditorManager()
```

#### 默认Manager

`Model._default_manager`

​	模型遇到的第一个 `Manager` 为默认  `Manager` 。也可以使用 [`Meta.default_manager_name`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.default_manager_name) 来指定默认的。

#### 基础管理类

`Model._base_manager`

##### 使用manager 访问相关对象

​	Django 默认使用  `Model._base_manager` 去访问相关对象，而不是`_default_manager` 。

​	通过 [`Meta.base_manager_name`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.base_manager_name) 我们可以指定自己的实现。只能使用于自身模型。

##### 不要丢弃这种manager返回的结果

​	我们通过这个所有相关的对象，如果我们覆盖了 `get_queryset()` ，丢弃一些数据，将会得到不正确的结果。

#### 从管理类调用自定义的 QuerySet 方法

```python
class PersonQuerySet(models.QuerySet):
    def authors(self):
        return self.filter(role='A')

    def editors(self):
        return self.filter(role='E')

class PersonManager(models.Manager):
    def get_queryset(self):
        return PersonQuerySet(self.model, using=self._db)

    def authors(self):
        return self.get_queryset().authors() # 调用QuerySet的方法

    def editors(self):
        return self.get_queryset().editors()

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    role = models.CharField(max_length=1, choices=(('A', _('Author')), ('E', _('Editor'))))
    people = PersonManager()
```

#### 使用QuerySet方法创建 manager

​	上面的方法我们需要 重复 QuerySet 和 Manager 的方法。

​	[`QuerySet.as_manager()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.as_manager)  可以创建复制了 自定义QuerySet 方法的 Manager 实例：

```python
class Person(models.Model):
    ...
    people = PersonQuerySet.as_manager()
```

​	并不是所有的 QuerySet 方法都会被复制，遵循下面规则：

- 公有 方法默认进行复制
- 私有方法（以下划线开始）默认不复制
- 有`queryset_only` = False 属性的方法复制
- 有`queryset_only` = True 属性的方法不复制

```python
class CustomQuerySet(models.QuerySet):
    # Available on both Manager and QuerySet.
    def public_method(self):
        return

    # Available only on QuerySet.
    def _private_method(self):
        return

    # Available only on QuerySet.
    def opted_out_public_method(self):
        return
    opted_out_public_method.queryset_only = True

    # Available on both Manager and QuerySet.
    def _opted_in_private_method(self):
        return
    _opted_in_private_method.queryset_only = False
```

##### from_queryset()

​	同时要自定义的manager 和 自定义的 QuerySet：

```python
class BaseManager(models.Manager):
    def manager_only_method(self):
        return

class CustomQuerySet(models.QuerySet):
    def manager_and_queryset_method(self):
        return

class MyModel(models.Model):
    objects = BaseManager.from_queryset(CustomQuerySet)()
```

可以将manager 存入变量：

```python
CustomManager = BaseManager.from_queryset(CustomQuerySet)

class MyModel(models.Model):
    objects = CustomManager()
```

#### 自定义的manager和模型继承

​	遵循以下规则：

1. Managers from base classes are always inherited by the child class,using Python’s normal name resolution order (names on the childclass override all others; then **come names on the first parent class**,and so on).
2. If no managers are declared on a model and/or its parents, Django automatically creates the `objects` manager.
3. The default manager on a class is either the one chosen with[`Meta.default_manager_name`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.default_manager_name), or the **first manager declared** on the model, or the **default manager of the first parent model**.

```python
class AbstractBase(models.Model):
    # ...
    objects = CustomManager()

    class Meta:
        abstract = True
        
class ChildA(AbstractBase):
    # ...
    # This class has CustomManager as the default manager.
    pass

class ChildB(AbstractBase):
    # ...
    # An explicit default manager.objects manager is still available
    default_manager = OtherManager()
    
    
class ExtraManager(models.Model):
    extra_manager = OtherManager()

    class Meta:
        abstract = True

class ChildC(AbstractBase, ExtraManager):
    # ...
    # Default manager is CustomManager, but OtherManager is
    # also available via the "extra_manager" attribute.
    pass
```

#### 实现关注点

> Whatever features you add to your custom `Manager`, it must be possible to make a shallow copy of a `Manager` instance; 

```python
>>> import copy
>>> manager = MyManager()
>>> my_copy = copy.copy(manager)
```

​	如果不能拷贝，查询就会失败。

> if you’re overriding `__getattr__` or some other private method of your `Manager` object that controls object state, you should ensure that you don’t affect the ability of your `Manager` to be copied.

## 2.6 原始SQL查询

​	要么使用 Manager.raw() ，要么直接运行自定义 SQL。

### 2.6.1  运行 raw 查询

`Manager.raw(*raw_query*, *params=None*, *translations=None*)`

返回 `django.db.models.query.RawQuerySet` 可以进行迭代。

```python
class Person(models.Model):
    first_name = models.CharField(...)
    last_name = models.CharField(...)
    birth_date = models.DateField(...)
```

```python
>>> for p in Person.objects.raw('SELECT * FROM myapp_person'):
...     print(p)
John Smith
Jane Jones
```

​	**注意：**传递给 raw（） 的没有进行检查。在MySQL中默认的类型转换可能会引起意外的错误。RawQuerySet 没有完全实现像 QuerySet 一样的方法（`__bool__()`  `__len__()` ）

> The reason these methods are not implemented in `RawQuerySet` is that implementing them without internal caching would be a performance drawback and adding such caching would be backward incompatible.

#### 将 查询字段 映射到 模型字段（raw（）自动完成）

```python
>>> Person.objects.raw('SELECT id, first_name, last_name, birth_date FROM myapp_person')
...#  顺序无关，因此是等价的
>>> Person.objects.raw('SELECT last_name, birth_date, first_name, id FROM myapp_person')
...
```

```python
# 通过名字映射散，因此 可以使用AS 映射到 模型字段。
>>> Person.objects.raw('''SELECT first AS first_name,
...                              last AS last_name,
...                              bd AS birth_date,
...                              pk AS id,
...                       FROM some_other_table''')
```

```python
# 使用 translations 参数来映射
>>> name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'}
>>> Person.objects.raw('SELECT * FROM some_other_table', translations=name_map)
```

#### index lookups

 	raw（）支持索引

```python
>>> first_person = Person.objects.raw('SELECT * FROM myapp_person')[0]

# 但是索引，切片不在 数据库层，性能差一点
>>> first_person = Person.objects.raw('SELECT * FROM myapp_person LIMIT 1')[0]
```

####  Deferring model fields

```python
# 没有返回的字段需要重新去数据库查，主键除外(唯一标识对象)
>>> for p in Person.objects.raw('SELECT id, first_name FROM myapp_person'):
...     print(p.first_name, # This will be retrieved by the original query
...           p.last_name) # This will be retrieved on demand
...
John Smith
Jane Jones
```

#### 添加annotations

```python
>>> people = Person.objects.raw('SELECT *, age(birth_date) AS age FROM myapp_person')
>>> for p in people:
...     print("%s is %s." % (p.first_name, p.age))
John is 37.
Jane is 42.
...
```

#### 给 raw（） 传入参数

```python
>>> lname = 'Doe'
>>> Person.objects.raw('SELECT * FROM myapp_person WHERE last_name = %s', [lname])
# 列表 %s
# 字典 %(key)s  ( key 会被字典的 key 替换)     SQLite 不支持
```

### 2.6.2 直接运行自定义 SQL

​	 `django.db.connection` 表示数据库连接；

​	`connection.cursor()`   获取游标对象

​	`cursor.execute(sql, [params])` 执行 SQl

​	`cursor.fetchone()` or `cursor.fetchall()`  返回结果

```python
from django.db import connection

def my_custom_sql(self):
    with connection.cursor() as cursor:
        cursor.execute("UPDATE bar SET foo = 1 WHERE baz = %s", [self.baz])
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
        row = cursor.fetchone()

    return row
```

```python
cursor.execute("SELECT foo FROM bar WHERE baz = '30%'")
cursor.execute("SELECT foo FROM bar WHERE baz = '30%%' AND id = %s", [self.id]) 	# 想使用 % 必须使用两个 %%
```

​	当[more than one database](https://docs.djangoproject.com/en/1.11/topics/db/multi-db/), 可以使用`django.db.connections`获取指定连接：

```python
from django.db import connections
cursor = connections['my_db_alias'].cursor()
# Your code here...
```

​	默认情况下 python DB api 返回的结果，没有字段名。

```python
def dictfetchall(cursor):
    "Return all rows from a cursor as a dict"
    columns = [col[0] for col in cursor.description]
    return [
        dict(zip(columns, row))
        for row in cursor.fetchall()
    ]
```

​	也可以使用： [`collections.namedtuple()`](https://docs.python.org/3/library/collections.html#collections.namedtuple) ，A `namedtuple` is a tuple-like object that has fields accessible by attribute lookup

```python
from collections import namedtuple

def namedtuplefetchall(cursor):
    "Return all rows from a cursor as a namedtuple"
    desc = cursor.description
    nt_result = namedtuple('Result', [col[0] for col in desc])
    return [nt_result(*row) for row in cursor.fetchall()]
```



```python
>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2");
>>> cursor.fetchall()
((54360982, None), (54360880, None))

>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2");
>>> dictfetchall(cursor)
[{'parent_id': None, 'id': 54360982}, {'parent_id': None, 'id': 54360880}]

>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2");
>>> results = namedtuplefetchall(cursor)
>>> results
[Result(id=54360982, parent_id=None), Result(id=54360880, parent_id=None)]
>>> results[0].id
54360982
>>> results[0][0]
54360982
```

#### 连接 与 游标

​	`cursor.execute()` uses placeholders, `"%s"`

```python
with connection.cursor() as c:
    c.execute(...)
    
# 等价于

c = connection.cursor()
try:
    c.execute(...)
finally:
    c.close()
```

## 2.7 数据库事务

### 2.7.1 管理数据库事务

#### django 默认事务行为

​	默认运行在 autocommit 模式。

​	Django 使用 事务， savepoint 确保完整性

​	[`TestCase`](https://docs.djangoproject.com/en/1.11/topics/testing/tools/#django.test.TestCase) 中的每个测试都是作为事务

#### http 请求事务

​	处理 http 请求事务，在数据库配置中将  [`ATOMIC_REQUESTS`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASE-ATOMIC_REQUESTS)   设为 True。

​	在开始调用 view 函数之前，Django 开始事务。如果产生的响应没有异常，Django 提交事务；否则，Django 回滚事务。

​	当启用了 [`ATOMIC_REQUESTS`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASE-ATOMIC_REQUESTS) ，使用`non_atomic_requests`(*using=None*)[[source\]](https://docs.djangoproject.com/en/1.11/_modules/django/db/transaction/#non_atomic_requests) 可以取消 view 的事务：

```python
from django.db import transaction

@transaction.non_atomic_requests
def my_view(request):
    do_stuff()

@transaction.non_atomic_requests(using='other')
def my_other_view(request):
    do_stuff_on_the_other_database()
```

​	在实际中，view 函数的事务可以使用[`atomic()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.atomic)  修饰符。

#### 显示控制事务

`atomic`(*using=None*, *savepoint=True*)

​	atomic 块可以嵌套，当内部提交之后，还可以回滚。

​	atomic 可以作为  [decorator](https://docs.python.org/3/glossary.html#term-decorator) 和 [context manager](https://docs.python.org/3/glossary.html#term-context-manager):

```python
from django.db import transaction

@transaction.atomic
def viewfunc(request):
    # This code executes inside a transaction.
    do_stuff()
```

```python
from django.db import transaction

def viewfunc(request):
    # This code executes in autocommit mode (Django's default).
    do_stuff()

    with transaction.atomic():
        # This code executes inside a transaction.
        do_more_stuff()
```

​	也可以将 atomic 放入 try/except 来处理异常

```python
from django.db import IntegrityError, transaction

@transaction.atomic
def viewfunc(request):
    create_parent()

    try:
        with transaction.atomic():
            generate_relationships()
    except IntegrityError:
        handle_exception()

    add_children()
```

注意：避免在atomic 中捕获异常。在结束的时候Django 是根据有无异常进行回滚或提交。如果在内部捕获，会导致意外的行为

​	为了确保原子性，atomic 禁用了一些 api。 在atomic 代码块去 commit、roll back，改变 autocommit的状态 会抛出异常。

​	atomic 使用 using 参数来表示使用的数据库。如果没有此参数，django 会使用 “default” 数据库。

### 2.7.2  Autocommit

#### django 为什么使用 autocommit

> In other words, not only does each such query start a transaction, but the transaction also gets automatically committed or rolled back, depending on whether the query succeeded.

#### 关闭事务管理

​	需要将数据库中的  [`AUTOCOMMIT`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASE-AUTOCOMMIT) 设置设为 False。

### 2.7.3 提交后的动作

​	Django 提供 [`on_commit()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.on_commit)  来注册事务成功提交之后的回调函数。

`on_commit`(*func*, *using=None*)

```python
from django.db import transaction

def do_something():
    pass  # send a mail, invalidate a cache, fire off a Celery task, etc.

transaction.on_commit(do_something)
```

​	也可以使用 lambda 封装函数:

```python
transaction.on_commit(lambda: some_celery_task.delay('arg1'))
```

​	当调用on_commit（）时没有启用事务，那么回调函数会立即执行(在autocommit 模式)。

#### Savepoints

>an [`on_commit()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.on_commit) callable registered after a savepoint (in a nested [`atomic()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.atomic) block) will be called after the outer transaction is committed

```python
with transaction.atomic():  # Outer atomic, start a new transaction
    transaction.on_commit(foo)

    with transaction.atomic():  # Inner atomic block, create a savepoint
        transaction.on_commit(bar)

# foo() and then bar() will be called when leaving the outermost block
```

```python
with transaction.atomic():  # Outer atomic, start a new transaction
    transaction.on_commit(foo)

    try:
        with transaction.atomic():  # Inner atomic block, create a savepoint
            transaction.on_commit(bar)
            raise SomeError()  # Raising an exception - abort the savepoint
    except SomeError:
        pass

# foo() will be called, but not bar()
```

#### Order of execution

​	依据注册时的顺序。

#### Exception handling

​	如果出现异常，则同一事物之后的注册函数不会被调用。这个与普通函数的行为是一致的。

#### Timing of execution

​	回调函数的执行是在成功提交之后，因此回调中的异常不会引起事务回滚。

​	如果想让回调函数的异常引起回滚，应该使用[two-phase commit](https://en.wikipedia.org/wiki/Two-phase_commit_protocol) （[psycopg Two-Phase Commit protocol support](http://initd.org/psycopg/docs/usage.html#tpc)
and the [optional Two-Phase Commit Extensions in the Python DB-APIspecification](https://www.python.org/dev/peps/pep-0249/#optional-two-phase-commit-extensions).）

> On-commit functions only work with [autocommit mode](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#managing-autocommit) and the [`atomic()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.atomic) (or [`ATOMIC_REQUESTS`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASE-ATOMIC_REQUESTS)) transaction API.Calling [`on_commit()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.on_commit) when autocommit is disabled and you are not within an atomic block will result in an error.

#### Use in tests

​	 [`TestCase`](https://docs.djangoproject.com/en/1.11/topics/testing/tools/#django.test.TestCase) 的每个测试都是一个事务，当完成之后就会回滚。如果需要测试 on_commit() 的回调，应该使用[`TransactionTestCase`](https://docs.djangoproject.com/en/1.11/topics/testing/tools/#django.test.TransactionTestCase)

#### Why no rollback hook?

> A rollback hook is harder to implement robustly than a commit hook, since a variety of things can cause an implicit rollback.

### 2.7.4 底层 api

​	只有实现自己的事务管理，这些底层 api 才有用。

#### autocommit

​	[`django.db.transaction`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#module-django.db.transaction) 提供了api 来管理数据库连接的 autocommit 状态。

`get_autocommit`(*using=None*)

`set_autocommit`(*autocommit*, *using=None*)

#### transactions ???

> Django doesn’t provide an API to start a transaction. The expected way to start a transaction is to disable autocommit with [`set_autocommit()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.set_autocommit).

#### savepoints

> Savepoints aren’t especially useful if you are using autocommit, the default behavior of Django.

​	当 atomic（）修饰符嵌套时，就创建一个savepoint ，可以局部提交或回滚。推荐使用atomic ，而不是下面的Api。

| api                                      | 含义             |                                          |
| ---------------------------------------- | -------------- | ---------------------------------------- |
| `savepoint`(*using=None*)                | 创建，返回sid       | 如果不支持savepoint，或者数据库在autocommit模式，这些函数 什么也不做 |
| `savepoint_commit`(*sid*, *using=None*)  | 提交             | ...                                      |
| `savepoint_rollback`(*sid*, *using=None*) | 回滚             | ...                                      |
| `clean_savepoints`(*using=None*)         | 重置计数，易产生唯一 sid |                                          |

```python
from django.db import transaction

# open a transaction
@transaction.atomic
def viewfunc(request):

    a.save()
    # transaction now contains a.save()

    sid = transaction.savepoint()

    b.save()
    # transaction now contains a.save() and b.save()

    if want_to_keep_b:
        transaction.savepoint_commit(sid)
        # open transaction still contains a.save() and b.save()
    else:
        transaction.savepoint_rollback(sid)
        # open transaction now contains only a.save()
```

​	由于不晓得调用了底层api，在 atomic（）里面使用仍有可能会被回滚，我们可以使用下面函数来控制回滚行为：

`get_rollback`(*using=None*)

`set_rollback`(*rollback*, *using=None*)

### 2.7.4 数据库相关

#### Savepoints in SQLite

SQLite >=3.6.8 支持 savepoint。

When autocommit is enabled, savepoints don’t make sense. When it’s disabled, [`sqlite3`](https://docs.python.org/3/library/sqlite3.html#module-sqlite3) commits implicitly before savepoint statements.

- The low level APIs for savepoints are only usable inside a transaction ie.inside an [`atomic()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.atomic) block.
- It’s impossible to use [`atomic()`](https://docs.djangoproject.com/en/1.11/topics/db/transactions/#django.db.transaction.atomic) when autocommit is turned off.

#### Transactions in MySQL

​	If your MySQL setup does *not* support transactions, then Django will always function in autocommit mode: statements will be executed and committed as soon as they’re called. If your MySQL setup *does* support transactions, Django will handle transactions as explained in this document.

#### 处理 PostgreSQL 事务的异常

​	注意： 此处用于自己实现事务管理。

##### 事务回滚

回滚整个事务

```python
a.save() # Succeeds, but may be undone by transaction rollback
try:
    b.save() # Could throw exception
except IntegrityError:
    transaction.rollback()
c.save() # Succeeds, but a.save() may have been undone
```

​	没有提交的数据库操作都会丢失。上面的 a.save（）就会丢失，尽管没有出现错误。

##### savepoint rollback

```python
a.save() # Succeeds, and never undone by savepoint rollback
sid = transaction.savepoint()
try:
    b.save() # Could throw exception
    transaction.savepoint_commit(sid)
except IntegrityError:
    transaction.savepoint_rollback(sid)
c.save() # Succeeds, and a.save() is never undone
```

## 2.8 多数据库

### 2.8.1 定义多个数据库

​	通过 [`DATABASES`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASES)  设置定义多个数据库。通过字典映射别名到某个连接的设置字典。

```python
DATABASES = {
    'default': {
        'NAME': 'app_data',
        'ENGINE': 'django.db.backends.postgresql',
        'USER': 'postgres_user',
        'PASSWORD': 's3krit'
    },
    'users': {
        'NAME': 'user_data',
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mysql_user',
        'PASSWORD': 'priv4te'
    }
}
```

​	default 条目需要被定义，但是可以为空。

​	对所有的app 设置 [`DATABASE_ROUTERS`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASE_ROUTERS) 来防止查询路由到默认数据库。

```python
DATABASES = {
    'default': {},
    'users': {
        'NAME': 'user_data',
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mysql_user',
        'PASSWORD': 'superS3cret'
    },
    'customers': {
        'NAME': 'customer_data',
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mysql_cust',
        'PASSWORD': 'veryPriv@ate'
    }
}
```

### 2.8.2 同步多个数据库

​	 [`migrate`](https://docs.djangoproject.com/en/1.11/ref/django-admin/#django-admin-migrate) 管理命令一次操作一个数据库。默认操作default 数据库。通过[`--database`](https://docs.djangoproject.com/en/1.11/ref/django-admin/#cmdoption-migrate-database) 选项，可以同步指定的数据库。

#### 使用其它管理命令

​	 [`makemigrations`](https://docs.djangoproject.com/en/1.11/ref/django-admin/#django-admin-makemigrations) 在创建新迁移之前，会验证数据库迁移的历史，以找到问题。默认会检查default 数据库，如果使用了 [routers](https://docs.djangoproject.com/en/1.11/topics/db/multi-db/#topics-db-multi-db-routing) 会查询  [`allow_migrate()`](https://docs.djangoproject.com/en/1.11/topics/db/multi-db/#allow_migrate) 方法。

### 2.8.3 自动数据库路由

​	使用多数据库最简单的方式就是设置数据库路由策略。

​	Django项目提供了默认的路由策略。如果想实现更有趣的数据库分配行为，可以定义，安装自己的数据库路由。

#### 数据库路由

​	一个数据库路由是提供四个方法的类：

`db_for_read`(*model*, **\*hints*)

`db_for_write`(*model*, **\*hints*)	

`allow_relation`(*obj1*, *obj2*, **\*hints*)

`allow_migrate`(*db*, *app_label*, *model_name=None*, **\*hints*）

##### hints

> At present, the only hint that will be provided is `instance`, an object instance that is related to the read or write operation that is underway.This might be the instance that is being saved, or it might
> be an instance that is being added in a many-to-many relation.

#### 使用 路由

​	通过  [`DATABASE_ROUTERS`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASE_ROUTERS) 设置来安装路由。

#### 示例

```python
DATABASES = {
    'default': {},
    'auth_db': {
        'NAME': 'auth_db',
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mysql_user',
        'PASSWORD': 'swordfish',
    },
    'primary': {
        'NAME': 'primary',
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mysql_user',
        'PASSWORD': 'spam',
    },
    'replica1': {
        'NAME': 'replica1',
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mysql_user',
        'PASSWORD': 'eggs',
    },
    'replica2': {
        'NAME': 'replica2',
        'ENGINE': 'django.db.backends.mysql',
        'USER': 'mysql_user',
        'PASSWORD': 'bacon',
    },
}
```

```python
class AuthRouter(object):
    """
    A router to control all database operations on models in the
    auth application.
    """
    def db_for_read(self, model, **hints):
        """
        Attempts to read auth models go to auth_db.
        """
        if model._meta.app_label == 'auth':
            return 'auth_db'
        return None

    def db_for_write(self, model, **hints):
        """
        Attempts to write auth models go to auth_db.
        """
        if model._meta.app_label == 'auth':
            return 'auth_db'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """
        Allow relations if a model in the auth app is involved.
        """
        if obj1._meta.app_label == 'auth' or \
           obj2._meta.app_label == 'auth':
           return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """
        Make sure the auth app only appears in the 'auth_db'
        database.
        """
        if app_label == 'auth':
            return db == 'auth_db'
        return None
```

```python
import random

class PrimaryReplicaRouter(object):
    def db_for_read(self, model, **hints):
        """
        Reads go to a randomly-chosen replica.
        """
        return random.choice(['replica1', 'replica2'])

    def db_for_write(self, model, **hints):
        """
        Writes always go to primary.
        """
        return 'primary'

    def allow_relation(self, obj1, obj2, **hints):
        """
        Relations between objects are allowed if both objects are
        in the primary/replica pool.
        """
        db_list = ('primary', 'replica1', 'replica2')
        if obj1._state.db in db_list and obj2._state.db in db_list:
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """
        All non-auth models end up in this pool.
        """
        return True
```

```python
DATABASE_ROUTERS = ['path.to.AuthRouter', 'path.to.PrimaryReplicaRouter']
```

```python
>>> # This retrieval will be performed on the 'auth_db' database
>>> fred = User.objects.get(username='fred')
>>> fred.first_name = 'Frederick'

>>> # This save will also be directed to 'auth_db'
>>> fred.save()

>>> # These retrieval will be randomly allocated to a replica database
>>> dna = Person.objects.get(name='Douglas Adams')

>>> # A new object has no database allocation when created
>>> mh = Book(title='Mostly Harmless')

>>> # This assignment will consult the router, and set mh onto
>>> # the same database as the author object
>>> mh.author = dna

>>> # This save will force the 'mh' instance onto the primary database...
>>> mh.save()

>>> # ... but if we re-retrieve the object, it will come back on a replica
>>> mh = Book.objects.get(title='Mostly Harmless')
```

### 2.8.4 手动选择数据库

​	手动选择优先于自动路由。

#### QuerySet 手动选择数据库

```python
>>> # This will run on the 'default' database.
>>> Author.objects.all()

>>> # So will this.
>>> Author.objects.using('default').all()

>>> # This will run on the 'other' database.
>>> Author.objects.using('other').all()
```

#### 给 save（） 方法选择数据库

```python
>>> my_object.save(using='legacy_users')
```

##### 将数据从一个数据库移动到另一个数据库

方法一：

```python
>>> p = Person(name='Fred')
>>> p.save(using='first')
>>> p.pk = None # Clear the primary key.
>>> p.save(using='second') # Write a completely new object.
```

方法二：（在两个数据库中有相同的主键，如果主键已存在，则出错）

```
>>> p = Person(name='Fred')
>>> p.save(using='first')
>>> p.save(using='second', force_insert=True)
```

#### 选择从哪个数据库删除

默认从获取对象的数据库删除：

```python
>>> u = User.objects.using('legacy_users').get(username='fred')
>>> u.delete() # will delete from the `legacy_users` database
```

数据库迁移：

```python
>>> user_obj.save(using='new_users')
>>> user_obj.delete(using='legacy_users')
```

#### 在多个数据库中使用 manager

​	在 manager上使用 `db_manager()` 来访问非默认数据库。

> `db_manager()` returns a copy of the manager bound to the database you specify.

```python
User.objects.db_manager('new_users').create_user(...)
```

##### 在多个数据库中使用 get_queryset() ???

​	如果覆盖了 manager 的`get_queryset()` 方法，确保要调用父类的方法，或者适当处理 _db 属性。

```python
class MyManager(models.Manager):
    def get_queryset(self):
        qs = CustomQuerySet(self.model)
        if self._db is not None:
            qs = qs.using(self._db)
        return qs
```

### 2.8.5 在Django 管理界面暴露多个数据库???

​	实现自己的[`ModelAdmin`](https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#django.contrib.admin.ModelAdmin)  类：

```python
class MultiDBModelAdmin(admin.ModelAdmin):
    # A handy constant for the name of the alternate database.
    using = 'other'

    def save_model(self, request, obj, form, change):
        # Tell Django to save objects to the 'other' database.
        obj.save(using=self.using)

    def delete_model(self, request, obj):
        # Tell Django to delete objects from the 'other' database
        obj.delete(using=self.using)

    def get_queryset(self, request):
        # Tell Django to look for objects on the 'other' database.
        return super(MultiDBModelAdmin, self).get_queryset(request).using(self.using)

    def formfield_for_foreignkey(self, db_field, request, **kwargs):
        # Tell Django to populate ForeignKey widgets using a query
        # on the 'other' database.
        return super(MultiDBModelAdmin, self).formfield_for_foreignkey(db_field, request, using=self.using, **kwargs)

    def formfield_for_manytomany(self, db_field, request, **kwargs):
        # Tell Django to populate ManyToMany widgets using a query
        # on the 'other' database.
        return super(MultiDBModelAdmin, self).formfield_for_manytomany(db_field, request, using=self.using, **kwargs)
```

[`InlineModelAdmin`](https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#django.contrib.admin.InlineModelAdmin) objects can be handled in a similar fashion.

```python
class MultiDBTabularInline(admin.TabularInline):
    using = 'other'

    def get_queryset(self, request):
        # Tell Django to look for inline objects on the 'other' database.
        return super(MultiDBTabularInline, self).get_queryset(request).using(self.using)

    def formfield_for_foreignkey(self, db_field, request, **kwargs):
        # Tell Django to populate ForeignKey widgets using a query
        # on the 'other' database.
        return super(MultiDBTabularInline, self).formfield_for_foreignkey(db_field, request, using=self.using, **kwargs)

    def formfield_for_manytomany(self, db_field, request, **kwargs):
        # Tell Django to populate ManyToMany widgets using a query
        # on the 'other' database.
        return super(MultiDBTabularInline, self).formfield_for_manytomany(db_field, request, using=self.using, **kwargs)
```

```python
from django.contrib import admin

# Specialize the multi-db admin objects for use with specific models.
class BookInline(MultiDBTabularInline):
    model = Book

class PublisherAdmin(MultiDBModelAdmin):
    inlines = [BookInline]

admin.site.register(Author, MultiDBModelAdmin)
admin.site.register(Publisher, PublisherAdmin)

othersite = admin.AdminSite('othersite')
othersite.register(Publisher, MultiDBModelAdmin)
```

### 2.8.6 在多个数据库中使用 raw cursors

```python
from django.db import connections
cursor = connections['my_db_alias'].cursor()
```

### 2.8.7 多数据库的限制???

#### 跨数据库关系



#### Behavior of contrib apps

some restrictions onhow you can split these models across databases:

- each one of `contenttypes.ContentType`, `sessions.Session` and`sites.Site` can be stored in any database, given a suitable router.
- `auth` models — `User`, `Group` and `Permission` — are linked together and linked to `ContentType`, so they must be stored in the samedatabase as `ContentType`.
- `admin` depends on `auth`, so its models must be in the same databaseas `auth`.
- `flatpages` and `redirects` depend on `sites`, so their models must bein the same database as `sites`.

some objects are automatically created just after[`migrate`](https://docs.djangoproject.com/en/1.11/ref/django-admin/#django-admin-migrate) creates a table to hold them in a database:

- a default `Site`,
- a `ContentType` for each model (including those not stored in thatdatabase),
- three `Permission` for each model (including those not stored in thatdatabase).



## 2.9 表空间

​	Django 并不提供 表空间。具体参考相关数据库引擎相关文档

### 2.9.1 给表声明表空间

​	A tablespace can be specified for the table generated by a model by supplyingthe [`db_tablespace`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.db_tablespace) option inside the model’s`class Meta`. This option also affects tables automatically created for[`ManyToManyField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField)s in the model.

You can use the [`DEFAULT_TABLESPACE`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DEFAULT_TABLESPACE) setting to specify a default value for [`db_tablespace`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.db_tablespace). This is useful for setting a tablespace for the built-in Django apps and other applications whose code you cannot control.

### 2.9.2 给索引声明表空间

​	You can pass the [`db_tablespace`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.db_tablespace) option to a`Field` constructor to specify an alternate tablespace for the `Field`’scolumn index. If no index would be created for the column, the option isignored.

You can use the [`DEFAULT_INDEX_TABLESPACE`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DEFAULT_INDEX_TABLESPACE) setting to specifya default value for [`db_tablespace`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.db_tablespace).

If [`db_tablespace`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.db_tablespace) isn’t specified and you didn’tset [`DEFAULT_INDEX_TABLESPACE`](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DEFAULT_INDEX_TABLESPACE), the index is created in the sametablespace as the tables.

### 2.9.3 示例

```python
class TablespaceExample(models.Model):
    name = models.CharField(max_length=30, db_index=True, db_tablespace="indexes")
    data = models.CharField(max_length=255, db_index=True)
    edges = models.ManyToManyField(to="self", db_tablespace="indexes")

    class Meta:
        db_tablespace = "tables"
```

### 2.9.4 数据库支持

PostgreSQL and Oracle support tablespaces. SQLite and MySQL don’t.（不支持会忽略这些选项）



## 2.10 数据库访问优化

​	[what queries you are doing and what they are costing you](https://docs.djangoproject.com/en/1.11/faq/models/#faq-see-raw-sql-queries).或者使用工具（[django-debug-toolbar](https://github.com/jazzband/django-debug-toolbar/),等）

### 2.10.1 标准数据库优化技术

- 索引：Use [`Field.db_index`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.db_index) or [`Meta.index_together`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.index_together) to add these from Django.
- 适合的字段类型

## 2.10.2 理解 QuerySet

#### 理解 QuerySet 的估价

- that [QuerySets are lazy](https://docs.djangoproject.com/en/1.11/topics/db/queries/#querysets-are-lazy).
- when [they are evaluated](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#when-querysets-are-evaluated).
- how [the data is held in memory](https://docs.djangoproject.com/en/1.11/topics/db/queries/#caching-and-querysets).

#### 理解缓存属性

In general, attributes that are not callable will be cached. 

```python
>>> entry = Entry.objects.get(id=1)
>>> entry.blog   # Blog object is retrieved at this point
>>> entry.blog   # cached version, no DB access
```

in general, callable attributes cause DB lookups every time:

```python
>>> entry = Entry.objects.get(id=1)
>>> entry.authors.all()   # query performed
>>> entry.authors.all()   # query performed again
```



#### 在标签模板中使用 with

To make use of the caching behavior of `QuerySet`, you may need to use the
[`with`](https://docs.djangoproject.com/en/1.11/ref/templates/builtins/#std:templatetag-with) template tag.

#### 使用迭代

When you have a lot of objects, the caching behavior of the `QuerySet` can
cause a large amount of memory to be used. In this case,
[`iterator()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.iterator) may help.

### 2.10.3能在数据库完成的工作就在数据库完成

- At the most basic level, use [filter and exclude](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#queryset-api) to dofiltering in the database.
- Use [`F expressions`](https://docs.djangoproject.com/en/1.11/ref/models/expressions/#django.db.models.F) to filterbased on other fields within the same model.
- Use [annotate to do aggregation in the database](https://docs.djangoproject.com/en/1.11/topics/db/aggregation/).

#### 使用 RawSQL

[`RawSQL`](https://docs.djangoproject.com/en/1.11/ref/models/expressions/#django.db.models.expressions.RawSQL) 

#### 使用 raw SQL

[custom SQL to retrieve data or populate models](https://docs.djangoproject.com/en/1.11/topics/db/sql/).

### 2.10.4 获取对象使用唯一，索引的列

There are two reasons to use a column with [`unique`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.unique) or [`db_index`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.db_index) when using [`get()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.get) to retrieve individual objects. First, the query will be quicker because of the underlying database index. Also, the query could run much slower if multiple objects match the lookup; having a unique constraint on the column guarantees this will never happen.

### 2.10.5 一次获取所需的所有数据

#### 使用`QuerySet.select_related()` and `prefetch_related()` 

[`select_related()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.select_related) and
[`prefetch_related()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.prefetch_related)

### 2.10.6 不要获取不需要的东西

#### 使用 QuerySet.values() 和 values_list()

#### 使用 QuerySet.defer() 和 only()

#### 使用 QuerySet.count()

#### 使用 QuerySet.exists()

#### 不要滥用 count() 和 exists()

#### 使用 QuerySet.update() 和delete()

#### 直接使用外键

```python
entry.blog_id
```

#### 不要对不关心的数据排序

​	remove it on a `QuerySet` by calling [`order_by()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.order_by) with no parameters.

### 2.10.7 批量插入

use the [`bulk_create()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.bulk_create) method to reduce the number of SQL queries



















