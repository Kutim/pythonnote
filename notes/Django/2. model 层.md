## 1. 模型

### 1.1 模型介绍

​	模型是关于数据单一、明确的信息源。包含存储数据的基本数据和行为。一般一个模型映射为单个数据库表

基础特征：

- 每一个模型是 django.db.models.Model 的子类
- 模型的每一个属性代表数据库中的一个字段
- django 提供相应的数据库访问 API

#### 1.1.1 快速入门

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

此模型会创建下面的数据库：

```sql
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

注意：

- 表名通过模型的元数据生成，也可以进行修改，详见 [Table name](https://docs.djangoproject.com/en/1.11/ref/models/options/#table-names)
- 一个id 字段被自动添加，也可以进行修改，详见 [Automatic primary key fields](https://docs.djangoproject.com/en/1.11/topics/db/models/#automatic-primary-key-fields)
- 上面SQL 是 PostgreSQL 格式的

#### 1.1.2  使用模型

​	把包含有自定义模型（models.py）的模块（manage.py startapp）名称，加入到 settings 文件(django-admin startproject )的 INSTALLED_APP 中

```python
INSTALLED_APPS = [
    #...
    'myapp',
    #...
]
```

​	当新加之后，务必使用 manage.py migrate ，以及可选的 manage.py makemigrations

#### 1.1.3 字段

​	字段通过类的属性来指定。注意名称不要与 [models API](https://docs.djangoproject.com/en/1.11/ref/models/instances/) (clean，save，delete)冲突。

示例：

```python
from django.db import models

class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)

class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()
```

##### 字段类型

​	模型中的字段都应该是 Field 类的实例。Django使用字段类类型决定：

- 数据库存储 列的存储类型

- 生成表格时前端组件的类型

- 简单的校验

  Django 定义的类型通过 [model field reference](https://docs.djangoproject.com/en/1.11/ref/models/fields/#model-field-types) 查看，也可以通过  [Writing custom model fields](https://docs.djangoproject.com/en/1.11/howto/custom-model-fields/) 自定义

##### 字段可选项

​	每一个字段带一些与字段相关的参数。也有一些通用的参数，例如

​	

| null        | 默认为 False，如果为True，数据库会存储空值作为 NULL        |
| ----------- | ---------------------------------------- |
| blank       | 默认为 False，如果为True，此字段允许使用空白              |
| choices     | 可迭代的二元组，对应前端的可选框                         |
| default     | 字段的默认值。可以为值 或 可调用对象                      |
| help_text   | 用于前端的组件显示                                |
| primary_key | 如果为真，此字段为主键。如果没有指定主键，会自己添加。主键字段是只读的，如果去修改，会创建一个新对象 |
| unique      | 如果为真，表示全表唯一                              |



使用 choices 的示例：（可以使用 get_XX_display() 获取相应的显示值）

```python
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```console
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

##### 自增主键字段

​	Django默认会给每一个模型下面字段：

```python
id = models.AutoField(primary_key=True)
```

##### 冗余字段名称

​	每个字段类型（除 ForeignKey, ManyToManyField , OneToOneField，第一个参数用于指定模型类，因此使用 verbose_name 命名参数）使用可选的第一个位置参数-冗余字段名称。如果没有此参数，Django 使用属性名（下划线转为空格）

##### 关系

###### 多对一关系

​	使用  [`django.db.models.ForeignKey`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey) 。需要使用位置参数，来指定与哪个模型关联。

例如：

```python
from django.db import models

class Manufacturer(models.Model):
    # ...
    pass

class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...
```

​	也可以创建 [recursive relationships](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和[relationships to models not yet defined](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships);

​	推荐外键字段名称为小写的相关模型

###### 多对多关系

​	使用[`ManyToManyField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField) 来定义。需要使用位置参数，来指定与哪个模型关联。

例如：

```python
from django.db import models

class Topping(models.Model):
    # ...
    pass

class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)
```

​	也可以创建 [recursive relationships](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和[relationships to models not yet defined](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships);

​	推荐ManyToManyField 字段的名称使用能够描述相关模型对象集。

​	ManyToManyField在哪个模型并没有什么关系。但是，只能放在一个中。

​	一般将ManyToManyField 放在需要编辑的对象中。（选择相应的标签）

###### 多对对关系的额外字段

​	当出现其他字段时，将多余的字段放入中间模型中。使用 through 关键字与中间模型关联。

例如：

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)
```

​	在中间模型中，显试使用外键指明多对多相关的模型。

​	中间模型有以下限制条件:

- 有且只有一个外键到源模型，或者显示使用  [`ManyToManyField.through_fields`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.through_fields).（此处与上面例子不符）
- 使用回环的多对多时，允许两个外键指向同一模型。当多于两个外键时，必须使用  `through_fields`
- 使用中间模型定义回环的多对多时，必须使用[`symmetrical=False`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.symmetrical)
- 中间模型在创建时，应当指定所有字段

###### 一对一关系

​	使用 [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) 来定义。特别适用于对象扩展对象的主键。

​	[One-to-one relationship model example](https://docs.djangoproject.com/en/1.11/topics/db/examples/one_to_one/) 

​	对于外键，可以定义[recursive relationship](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和 [references to as-yetundefined models](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships) 。

​	OneToOneField 可以接受 [`parent_link`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField.parent_link)  参数。

##### 跨文件模型

​	只需导入相应文件即可

```python
from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
    # ...
    zip_code = models.ForeignKey(
        ZipCode,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )
```

##### 字段名称限制

​	Django对于字段名称有两个限制：

- 字段名称不能是python 的保留字段，因为会影响 python 解析
- 字段名称不能包含两个以上的下划线 ，因为会影响 Django 的查询语法

##### 自定义字段类型

​	详见[Writing custom model fields](https://docs.djangoproject.com/en/1.11/howto/custom-model-fields/).

#### 1.1.4 元可选项

​	通过使用 内部类 Meta：

```python
from django.db import models

class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"

```

> Model metadata is “anything that’s not a field”, such as ordering options
> ([`ordering`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.ordering)), database table name ([`db_table`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.db_table)), or
> human-readable singular and plural names ([`verbose_name`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.verbose_name) and
> [`verbose_name_plural`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.verbose_name_plural)). None are required, and adding `class
> Meta` to a model is completely optional.

​	详见[modeloption reference](https://docs.djangoproject.com/en/1.11/ref/models/options/).

#### 1.1.5 模型属性

​	模型最重要的属性是[`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) 。用于查询

#### 1.1.6 模型方法

​	自定义模型方法添加了“row-level” 功能。 [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) methods are intended to do “table-wide” things

例如：

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        "Returns the person's full name."
        return '%s %s' % (self.first_name, self.last_name)
```

​	[methods automatically given to each model](https://docs.djangoproject.com/en/1.11/ref/models/instances/#model-instance-methods). 已有的方法。

##### 重写预定义的模型方法

​	例如：

```python
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        do_something()
        super(Blog, self).save(*args, **kwargs) # Call the "real" save() method.
        do_something_else()
```

##### 执行自定义SQL

​	[using raw SQL](https://docs.djangoproject.com/en/1.11/topics/db/sql/).

#### 1.1.7 模型继承

​	与普通的python 类继承一致。

​	你需要确定

#### 1.1.8 在包中组织模型

### 1.2 



## 2. 查询集



## 3. 模型实例



## 4. 迁移



## 5. 高级行为



## 6. 其他