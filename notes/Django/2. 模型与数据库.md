
[TOC]


# 2. 模型与数据库

## 2.1 模型

​	模型是关于数据单一、明确的信息源。包含存储数据的基本数据和行为。一般一个模型映射为单个数据库表

基础特征：

- 每一个模型是 django.db.models.Model 的子类
- 模型的每一个属性代表数据库中的一个字段
- django 提供相应的数据库访问 API

### 2.1.1 快速入门

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

此模型会创建下面的数据库：

```sql
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

注意：

- 表名通过模型的元数据生成，也可以进行修改，详见 [Table name](https://docs.djangoproject.com/en/1.11/ref/models/options/#table-names)
- 一个id 字段被自动添加，也可以进行修改，详见 [Automatic primary key fields](https://docs.djangoproject.com/en/1.11/topics/db/models/#automatic-primary-key-fields)
- 上面SQL 是 PostgreSQL 格式的

### 2.1.2 使用模型

​	把包含有自定义模型（models.py）的模块（manage.py startapp）名称，加入到 settings 文件(django-admin startproject )的 INSTALLED_APP 中

```python
INSTALLED_APPS = [
    #...
    'myapp',
    #...
]
```

​	当新加之后，务必使用 manage.py migrate ，以及可选的 manage.py makemigrations

### 2.1.3 字段（fields）

​	字段通过类的属性来指定。注意名称不要与 [models API](https://docs.djangoproject.com/en/1.11/ref/models/instances/) (clean，save，delete)冲突。

示例：

```python
from django.db import models

class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)

class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()
```

#### 字段类型

模型中的字段都应该是 Field 类的实例。Django使用字段类类型决定：

- 数据库存储 列的存储类型

- 生成表格时前端组件的类型

- 简单的校验

  Django 定义的类型通过 [model field reference](https://docs.djangoproject.com/en/1.11/ref/models/fields/#model-field-types) 查看，也可以通过  [Writing custom model fields](https://docs.djangoproject.com/en/1.11/howto/custom-model-fields/) 自定义

#### 字段可选项

每一个字段带一些与字段相关的参数。也有一些通用的参数，例如

| null        | 默认为 False，如果为True，数据库会存储空值作为 NULL        |
| ----------- | ---------------------------------------- |
| blank       | 默认为 False，如果为True，此字段允许使用空白              |
| choices     | 可迭代的二元组，对应前端的可选框（第一个为存储，第二个为显示）          |
| default     | 字段的默认值。可以为值 或 可调用对象                      |
| help_text   | 用于前端的组件显示                                |
| primary_key | 如果为真，此字段为主键。如果没有指定主键，会自己添加。主键字段是只读的，**如果去修改，会创建一个新对象** |
| unique      | 如果为真，表示全表唯一                              |

使用 choices 的示例：（可以使用 get_XX_display() 获取相应的显示值）

```python
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```console
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

#### 自增主键字段

​	Django默认会给每一个模型下面字段：

```python
id = models.AutoField(primary_key=True)
```

#### 冗余字段名称

​	每个字段类型（除 ForeignKey, ManyToManyField , OneToOneField，第一个参数用于指定模型类，因此使用 verbose_name 命名参数）使用可选的第一个位置参数-冗余字段名称。如果没有此参数，Django 使用属性名（下划线转为空格）

​	*用于制表的表头*

#### 关系

##### 多对一关系

​	使用  [`django.db.models.ForeignKey`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey) 。需要使用位置参数，来指定与哪个模型关联。

例如：

```python
from django.db import models

class Manufacturer(models.Model):
    # ...
    pass

class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...
```

​	也可以创建 [recursive relationships](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和[relationships to models not yet defined](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships);

​	推荐外键字段名称为小写的相关模型

​	访问反向关联对象示例：[Following relationships backward example](https://docs.djangoproject.com/en/1.11/topics/db/queries/#backwards-related-objects).

​	[Many-to-one relationship model example](https://docs.djangoproject.com/en/1.11/topics/db/examples/many_to_one/).

##### 多对多关系

​	使用   [`ManyToManyField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField) 来定义。需要使用位置参数，来指定与哪个模型关联。

例如：

```python
from django.db import models

class Topping(models.Model):
    # ...
    pass

class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)
```

​	也可以创建 [recursive relationships](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和[relationships to models not yet defined](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships);

​	推荐ManyToManyField 字段的名称使用能够描述相关模型对象集。

​	ManyToManyField在哪个模型并没有什么关系。但是，只能放在一个中。

​	一般将ManyToManyField 放在需要编辑的对象中。（选择相应的标签）

​	[Many-to-many relationship model example](https://docs.djangoproject.com/en/1.11/topics/db/examples/many_to_many/) 

##### 多对多关系的额外字段

​	当出现其他字段时，需要多余的字段放入中间模型中。使用 through 关键字与中间模型关联。

例如：

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)
```

​	在中间模型中，显试使用外键指明多对多相关的模型。

​	中间模型有以下限制条件:

- 有且只有一个外键到源模型，或者显示使用  [`ManyToManyField.through_fields`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.through_fields).（此处与上面例子不符）
- 使用回环的多对多时，允许两个外键指向同一模型。当多于两个外键时，必须使用  `through_fields`
- 使用中间模型定义回环的多对多时，必须使用[`symmetrical=False`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.symmetrical)
- 中间模型在创建时，应当指定所有字段

```shell
>>> ringo = Person.objects.create(name="Ringo Starr")
>>> paul = Person.objects.create(name="Paul McCartney")
>>> beatles = Group.objects.create(name="The Beatles")
>>> m1 = Membership(person=ringo, group=beatles,
...     date_joined=date(1962, 8, 16),
...     invite_reason="Needed a new drummer.")
>>> m1.save()
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>]>
>>> ringo.group_set.all()
<QuerySet [<Group: The Beatles>]>
>>> m2 = Membership.objects.create(person=paul, group=beatles,
...     date_joined=date(1960, 8, 1),
...     invite_reason="Wanted to form a band.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>

>>> # The following statements will not work
>>> beatles.members.add(john)
>>> beatles.members.create(name="George Harrison")
>>> beatles.members.set([john, paul, ringo, george])

>>> Membership.objects.create(person=ringo, group=beatles,
...     date_joined=date(1968, 9, 4),
...     invite_reason="You've been gone for a month and we miss you.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>, <Person: Ringo Starr>]>
>>> # This will not work because it cannot tell which membership to remove
>>> beatles.members.remove(ringo)

>>> # Beatles have broken up
>>> beatles.members.clear()
>>> # Note that this deletes the intermediate model instances
>>> Membership.objects.all()
<QuerySet []>

# Find all the groups with a member whose name starts with 'Paul'
>>> Group.objects.filter(members__name__startswith='Paul')
<QuerySet [<Group: The Beatles>]>


# Find all the members of the Beatles that joined after 1 Jan 1961
>>> Person.objects.filter(
...     group__name='The Beatles',
...     membership__date_joined__gt=date(1961,1,1))
<QuerySet [<Person: Ringo Starr]>

```

​	使用中间对象建立的多对多，在建立关系时，必须使用中间对象。查找时可以使用关联的属性。

[many-to-many reverse relationship](https://docs.djangoproject.com/en/1.11/topics/db/queries/#m2m-reverse-relationships) 

##### 一对一关系

​	使用   [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) 来定义。特别适用于对象扩展对象的主键。

​	[One-to-one relationship model example](https://docs.djangoproject.com/en/1.11/topics/db/examples/one_to_one/) 

​	对于外键，可以定义[recursive relationship](https://docs.djangoproject.com/en/1.11/ref/models/fields/#recursive-relationships) 和 [references to as-yetundefined models](https://docs.djangoproject.com/en/1.11/ref/models/fields/#lazy-relationships) 。

​	OneToOneField 可以接受  [`parent_link`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField.parent_link)  参数。

> [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) classes used to automatically become the primary key on a model. This is no longer true (although you can manually pass in the [`primary_key`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.Field.primary_key) argument if you like). Thus, it’s now possible to have multiple fields of type[`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) on a single model.

#### 跨文件模型

​	只需导入相应文件即可

```python
from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
    # ...
    zip_code = models.ForeignKey(
        ZipCode,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )
```

#### 字段名称限制

​	Django对于字段名称有两个限制：

- 字段名称不能是python 的保留字段，因为会影响 python 解析
- 字段名称不能包含两个以上的下划线 ，因为会影响 Django 的查询语法

#### 自定义字段类型

​	详见[Writing custom model fields](https://docs.djangoproject.com/en/1.11/howto/custom-model-fields/).

### 2.1.4 meta options

​	通过使用 内部类 Meta：

```python
from django.db import models

class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"
```

> Model metadata is “anything that’s not a field”, such as ordering options
> ([`ordering`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.ordering)), database table name ([`db_table`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.db_table)), or
> human-readable singular and plural names ([`verbose_name`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.verbose_name) and
> [`verbose_name_plural`](https://docs.djangoproject.com/en/1.11/ref/models/options/#django.db.models.Options.verbose_name_plural)). None are required, and adding `class
> Meta` to a model is completely optional.

​	详见[model option reference](https://docs.djangoproject.com/en/1.11/ref/models/options/).

### 2.1.5 模型属性

objects

​	模型最重要的属性是   [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) ，用于数据的操作。如果没有指定，默认为 [`objects`](https://docs.djangoproject.com/en/1.11/ref/models/class/#django.db.models.Model.objects)。 而且只能通过类访问。

### 2.1.6 模型方法

​	自定义模型方法添加了“row-level” 功能。 [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) methods are intended to do “table-wide” things

例如：

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        "Returns the person's full name."
        return '%s %s' % (self.first_name, self.last_name)
```

​	[methods automatically given to each model](https://docs.djangoproject.com/en/1.11/ref/models/instances/#model-instance-methods). [overriding predefined model methods](https://docs.djangoproject.com/en/1.11/topics/db/models/#overriding-predefined-model-methods),

#### 重写预定义的模型方法

​	例如：

```python
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        do_something()
        super(Blog, self).save(*args, **kwargs) # Call the "real" save() method.
        do_something_else()
```

#### 执行自定义SQL

​	[using raw SQL](https://docs.djangoproject.com/en/1.11/topics/db/sql/).

### 2.1.7 模型继承

​	与普通的python 类继承一致。

​	你需要确定父模型是否需要建立数据库表，或父模型拥有只能通过子模型访问的共有信息。

​	在 Django 中共拥有三种类型的继承：

- 使用父模型保存共有信息，[Abstract base classes](https://docs.djangoproject.com/en/1.11/topics/db/models/#abstract-base-classes) 最适合
- 如果创建一个模型的子模型，并且想让每个模型都有自己的数据库表，[Multi-table inheritance](https://docs.djangoproject.com/en/1.11/topics/db/models/#multi-table-inheritance) 最合适
- 如果只想修改模型的行为，[Proxy models](https://docs.djangoproject.com/en/1.11/topics/db/models/#proxy-models) 最合适

#### 抽象基类

​	写基类时，把 abstract=True 放入 Meta 中。这种方式基类不会生成数据库的表。基类的字段会添加到子类中。django 中不允许抽象基类中的字段与子类相同。

```python
from django.db import models

class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True

class Student(CommonInfo):
    home_group = models.CharField(max_length=5)
```

##### 元继承

​	如果子类中没有自己的 Meta 类，会继承父类的。如果想扩展父类的 Meta类，可以从它来继承。

```python
from django.db import models

class CommonInfo(models.Model):
    # ...
    class Meta:
        abstract = True
        ordering = ['name']

class Student(CommonInfo):
    # ...
    class Meta(CommonInfo.Meta):
        db_table = 'student_info'
```

​	Django 会对抽象基类中的 Meta 会做调整，（abstract = False）

##### 小心使用 related_name 和 related_query_name

​	如果  在  `ForeignKey` 或`ManyToManyField` 中使用 [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) 或[`related_query_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_query_name)  ，必须指定唯一反向字段。在抽象类中，会发生问题（包含在这所有子类中）。

​	为避免，在抽象基类中使用   [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) or
[`related_query_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_query_name) ，部分值必须包含`'%(app_label)s'` and
`'%(class)s'`. 

- `'%(class)s'` 会替换为小写的子类名
- `'%(app_label)s'`会替换为小写的子类所在app 名



app `common/models.py`:

```python
from django.db import models

class Base(models.Model):
    m2m = models.ManyToManyField(
        OtherModel,
        related_name="%(app_label)s_%(class)s_related",
        related_query_name="%(app_label)s_%(class)ss",
    )

    class Meta:
        abstract = True

class ChildA(Base):
    pass

class ChildB(Base):
    pass
```

app `rare/models.py`:

```python
from common.models import Base

class ChildB(Base):
    pass
```

> The reverse name of the `common.ChildA.m2m` field will be
> `common_childa_related` and the reverse query name will be `common_childas`.

如果没有指定    [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) 时，默认使用 XX（小写类名）_set

#### 多表继承

​	多层次模型，每个模型都有对应的数据库。子模型和父模型通过自动添加的 （[`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField)）(在子类中) 建立关系。

```python
from django.db import models

class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

class Restaurant(Place):
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)
```

​	如果一个 Place 也是 Restaurant，那么就可以得到 Restaurant

```
>>> p = Place.objects.get(id=12)
# If p is a Restaurant object, this will give the child class:
>>> p.restaurant
<Restaurant: ...>
```

​	自动添加在子类的关系如下：

```python
place_ptr = models.OneToOneField(
    Place, on_delete=models.CASCADE,
    parent_link=True,
)
```

##### 元和多表继承

​	元表已经用于父类，如果再用于子类，会导致矛盾行为

```python
class ChildModel(ParentModel):
    # ...
    class Meta:
        # Remove parent's ordering effect
        ordering = []
```

##### 继承与颠倒关系

​	由于存在   [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField) ，可以从父移动到子。

​	在如果想  在[`ManyToManyField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField) 中使用，必须指定[`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey.related_name) 。

```
class Supplier(Place):
    customers = models.ManyToManyField(Place, related_name='provider').
```

##### 指定父连接字段

​	如果想控制连接到父类的名称，可以自己创建 [`OneToOneField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField)  并指定 [`parent_link=True`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.OneToOneField.parent_link) 。

#### 代理模型

​	将 Meta 类的 proxy 属性设置为 True

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

class MyPerson(Person):
    class Meta:
        proxy = True

    def do_something(self):
        # ...
        pass
```

```
>>> p = Person.objects.create(first_name="foobar")
>>> MyPerson.objects.get(first_name="foobar")
<MyPerson: foobar>
```

​	也可以通过代理改变排序

```python
class OrderedPerson(Person):
    class Meta:
        ordering = ["last_name"]
        proxy = True
```

##### QuerySets 仍然返回相关的模型

​	Django 并不会返回代理类，代理类并不能代替原类。

##### 基础类限制

​	只能继承一个非抽象的类。可以继承多个抽象类。也可以从多个代理类继承（共享非抽象父类）

##### 代理模型管理

​	如果没有为定代理模型指定管理模型，则会继承父模型的。

```python
from django.db import models

class NewManager(models.Manager):
    # ...
    pass

class MyPerson(Person):
    objects = NewManager()		# 成为默认，也可访问父类的

    class Meta:
        proxy = True
```

​	如果想给代理添加新管理（不替换默认的），可以使用[custom manager](https://docs.djangoproject.com/en/1.11/topics/db/managers/#custom-managers-and-inheritance)  技术：创建包含管理的基类，然后继承

```python
# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
    secondary = NewManager()

    class Meta:
        abstract = True

class MyPerson(Person, ExtraManagers):
    class Meta:
        proxy = True
```

##### 代理继承与无管理模型的差异

> 1. If you are mirroring an existing model or database table and don’t wantall the original database table columns, use `Meta.managed=False`.That option is normally useful for modeling database views and tablesnot under the control of Django.
> 2. If you are wanting to change the Python-only behavior of a model, butkeep all the same fields as in the original, use `Meta.proxy=True`.This sets things up so that the proxy model is an exact copy of thestorage structure of the original model when data is saved.

#### 多继承

> Keep in mind that normal Python name resolution rules apply.

​	如只有第一个的Meta 起作用。

​	多继承用于 “mix-in”类：去增加一个字段或方法。在多继承中需在基类中显示使用 [`AutoField`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.AutoField) 字段，否则因默认的 ”id“ 会引起异常。也可以使用 共同的 祖先。

```python
class Article(models.Model):
    article_id = models.AutoField(primary_key=True)
    #...

class Book(models.Model):
    book_id = models.AutoField(primary_key=True)
    #...

class BookReview(Book, Article):
    pass
```

```python
class Piece(models.Model):
    pass

class Article(Piece):
   # ...

class Book(Piece):
   # ...

class BookReview(Book, Article):
    pass
```

#### 不许使用“hiding”字段

​	在一般类继承中，允许子类覆盖父类的属性。 但在 Django 中通常是不允许的。对于抽象基类并不适用。	

### 2.1.8 在包中组织模型

​	创建 models 目录（包含`__init__`.py）\

```python
#myapp/models/__init__.py
# 在 models 目录下有 organic.py 和 synthetic.py
from .organic import Person
from .synthetic import Robot
```

​	

## 2.2 查询

```python
# 使用示例
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Entry(models.Model):
    blog = models.ForeignKey(Blog)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    authors = models.ManyToManyField(Author)
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self):              # __unicode__ on Python 2
        return self.headline
```

### 2.2.1 创建对象

```shell
>>> from blog.models import Blog
>>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
>>> b.save()
```

​	当调用  [`save()`](https://docs.djangoproject.com/en/1.11/ref/models/instances/#django.db.models.Model.save) 方法时，才去数据库操作。 [`save()`](https://docs.djangoproject.com/en/1.11/ref/models/instances/#django.db.models.Model.save) 没有返回值。

​	如果想一步创建保存对象，可以使用 [`create()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.create) 

### 2.2.2 将改变保存到对象

```shell
>>> b5.name = 'New name'
>>> b5.save()
```

#### 保存外键和 ManyToManyField

外键：

```python
>>> from blog.models import Blog, Entry	# 当做普通对象
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()
```

ManyToMany:

```python
>>> from blog.models import Author		# 使用 add 方法
>>> joe = Author.objects.create(name="Joe")
>>> entry.authors.add(joe)

>>> john = Author.objects.create(name="John")	# 一次添加多个
>>> paul = Author.objects.create(name="Paul")
>>> george = Author.objects.create(name="George")
>>> ringo = Author.objects.create(name="Ringo")
>>> entry.authors.add(john, paul, george, ringo)
```

### 2.2.3 获取对象

​	通过 [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager)  构造 [`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) 。[`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) 代表从数据库取到的集合。每个模型至少有一个  [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) 即，[`objects`](https://docs.djangoproject.com/en/1.11/ref/models/class/#django.db.models.Model.objects) ，使用模型来访问

```python
>>> Blog.objects
<django.db.models.manager.Manager object at ...>
>>> b = Blog(name='Foo', tagline='Bar')
>>> b.objects
Traceback:
    ...
AttributeError: "Manager isn't accessible via Blog instances."
```

#### 获取所有

```python
>>> all_entries = Entry.objects.all()
```

#### 使用filter获取指定对象

`filter(**kwargs)` 返回满足条件的

`exclude(**kwargs)` 返回不满足条件的

参数的格式满足：[Field lookups](https://docs.djangoproject.com/en/1.11/topics/db/queries/#field-lookups) 

##### filter 链

QuerySet 查询的记过还是 QuerySet，因此可以链起来。

```python
>>> Entry.objects.filter(
...     headline__startswith='What'
... ).exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(
...     pub_date__gte=datetime(2005, 1, 30)
... )
```

##### 过滤的 QuerySets 是唯一的

```python
>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today())
```

​	这些QuerySet 是独立的。

##### QuerySets 是延时的

​	直到用到数据时才会去数据库操作。

#### 使用 get（）获取单个对象

​	如果确定结果只有一个，使用 get（） 直接返回。

​	如果没有找到 会抛出 `Entry.DoesNotExist`.

​	如果get（） 返回多个值，会抛出[`MultipleObjectsReturned`](https://docs.djangoproject.com/en/1.11/ref/exceptions/#django.core.exceptions.MultipleObjectsReturned), 

#### 其他 QuerySet 方法

​	[QuerySet API Reference](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#queryset-api) 

#### 限制 QuerySet

​	使用 python 的切片语法。可以达到与 SQL的 LIMIT 和OFFSET 相同的效果。

```python
>>> Entry.objects.all()[:5]        # (LIMIT 5):   返回 QuerySet
>>> Entry.objects.all()[5:10]		# (OFFSET 5 LIMIT 5): 返回 QuerySet

###  不支持负索引

>>> Entry.objects.all()[:10:2]		# 返回 List

>>> Entry.objects.order_by('headline')[0] #SELECT foo FROM bar LIMIT 1
# 等价于
>>> Entry.objects.order_by('headline')[0:1].get()

```

#### 字段查找

​	相当于 SQL 的 WHERE。格式`field__lookuptype=value`.

```python
>>> Entry.objects.filter(pub_date__lte='2006-01-01')		
```

对应 SQL语句：

```sql
SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';
```

​	这种方式归功于 python可以接受任意键值对，作为参数（在运行时确定值） [Keyword Arguments](https://docs.python.org/3/tutorial/controlflow.html#tut-keywordargs)

​	查询的字段必须为模型的字段。有一种情况例外，在外键中使用 field_id.

```python
>>> Entry.objects.filter(blog_id=4)
```

​	查询类型参考： [field lookup reference](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#field-lookups).

```python
>>> Blog.objects.get(id__exact=14)  # Explicit form
>>> Blog.objects.get(id=14)         # __exact is implied
```

#### 多表查询

​	使用相关联模型的字段

```python
>>> Entry.objects.filter(blog__name='Beatles Blog')
```

​	反向查询时，小写 模型名：

```python
>>> Blog.objects.filter(entry__headline__contains='Lennon')
```

​	如果跨越多表，但是中间模型没有满足条件，Django 会它当做空值，而不是抛出异常：

```python
Blog.objects.filter(entry__authors__name='Lennon')
```

如果 没有 author 与 entry 关联，也就没有与 name 关联。

```python
Blog.objects.filter(entry__authors__name__isnull=True)
```

会返回name 为空，与entry 相关 author 为空的 blog。

如果不想要author 为：

```python
Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)
```

##### 跨越多值关系  ^-^

```python
Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)		# 同时 (the same entry satisfying both conditions) 在多值关系中用于同一个
Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)		# 在多值关系中用于多个
```

> Everything inside a single [`filter()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter) call is applied simultaneously to filter out items matching all those requirements. 
>
> Successive [`filter()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter) calls further restrict the set of objects, but for multi-valued relations, they apply to any object linked to the primary model, not necessarily those objects that were selected by an earlier [`filter()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.filter) call.

Suppose there is only one blog that had both entries containing *“Lennon”* and
entries from 2008, but that none of the entries from 2008 contained *“Lennon”*.
The first query would not return any blogs, but the second query would return
that one blog.

 注意：

exclude 与 filter不同，条件不是同时满足

```python
Blog.objects.exclude(
    entry__headline__contains='Lennon',
    entry__pub_date__year=2008,
)# 达不到效果 应使用下面的：
Blog.objects.exclude(
    entry__in=Entry.objects.filter(
        headline__contains='Lennon',
        pub_date__year=2008,
    ),
)
```

#### 使用模型上的字段进行过滤

​	不同字段的比较，使用 [`F expressions`](https://docs.djangoproject.com/en/1.11/ref/models/expressions/#django.db.models.F) 

```python
>>> from django.db.models import F
>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
```

> Django supports the use of addition, subtraction, multiplication, division, modulo, and power arithmetic with `F()` objects, both with constants and with other `F()` objects.

​	在 F 表达式中也可以使用 __ 进行关系扩展。

```python
>>> Entry.objects.filter(authors__name=F('blog__name'))
```

​	在 F 表达式中也可以与 [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) 进行运算 （针对于时间）

```python
>>> from datetime import timedelta
>>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))
```

​	在 F 表达式中也可以进行位运算： `.bitand()`, `.bitor()`,
`.bitrightshift()`, and `.bitleftshift()`.

```python
>>> F('somefield').bitand(16)
```

#### 主键的快捷查找

​	Django 提供了  **pk**

```python
>>> Blog.objects.get(id__exact=14) # Explicit form
>>> Blog.objects.get(id=14) # __exact is implied
>>> Blog.objects.get(pk=14) # pk implies id__exact
```

```python
>>> Entry.objects.filter(blog__id__exact=3) # Explicit form
>>> Entry.objects.filter(blog__id=3)        # __exact is implied
>>> Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact		# 跨关系
```

#### 在 LIKE 语句中转义 百分号 下划线

​	自动转义（针对使用对象的查询）

```python
>>> Entry.objects.filter(headline__contains='%')	# 包含百分号的
```

​	对应SQL：

```SQL
SELECT ... WHERE headline LIKE '%\%%';
```

#### 缓存与 QuerySet

​	每个QuerySet 包含一个缓存以最小访问数据库。

```python
>>> print([e.headline for e in Entry.objects.all()])
>>> print([e.pub_date for e in Entry.objects.all()])
#	两次访问数据库，两次缓存，使用后丢弃

>>> queryset = Entry.objects.all()
>>> print([p.headline for p in queryset]) # Evaluate the query set.
>>> print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.
```

##### 不缓存QuerySet的情形

​	当对 QuerySet 的部分求值时

```python
>>> queryset = Entry.objects.all()
>>> print(queryset[5]) # Queries the database
>>> print(queryset[5]) # Queries the database again
```

```python
>>> queryset = Entry.objects.all()
>>> [entry for entry in queryset] # Queries the database
>>> print(queryset[5]) # Uses cache
>>> print(queryset[5]) # Uses cache
```

### 2.2. 4 用 Q 对象进行复杂查询

[`Q object`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.Q) (`django.db.models.Q`) 封装了查询条件（关键字参数）。

Q对象 可以使用 & 、| 和 ~ 进行联合，产生一个新的 Q对象

```python
Poll.objects.get(
    Q(question__startswith='Who'),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
```

等价于 SQL

```sql
SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')
```

​	Q 对象也可以与 关键字参数结合。但是Q 对象必须在前：

```python
Poll.objects.get(
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
    question__startswith='Who',
)


# INVALID QUERY
Poll.objects.get(
    question__startswith='Who',
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
```

​	[OR lookups examples](https://github.com/django/django/blob/master/tests/or_lookups/tests.py)

### 2.2.5 对象比较

​	两个模型实例的比较，只需使用标准的 python 比较运算。（==）比较主键：

```python
# 下面是等价的
>>> some_entry == other_entry
>>> some_entry.id == other_entry.id
```

### 2.2.6 删除对象

​	[`delete()`](https://docs.djangoproject.com/en/1.11/ref/models/instances/#django.db.models.Model.delete) 返回删除的数目，以及字典（包含删除的类型和数目）

```python
>>> e.delete()
(1, {'weblog.Entry': 1})

>>> Entry.objects.filter(pub_date__year=2005).delete()
(5, {'webapp.Entry': 5})
```

​	**记住：上面的作为纯SQL 执行，所以每个对象的 delete() 方法不会被调用。**

​	**如果我们提供一个 自定义的 delete()， 我们需要手动的调用每一个对象的 delete()**

> Note that [`delete()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.delete) is the only [`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) method that is not exposed on a [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) itself. 避免了意外全删   

### 2.2.7 复制模型实例

​	把 **pk** 设为**None**

```python
blog = Blog(name='My blog', tagline='Blogging is easy')
blog.save() # blog.pk == 1

blog.pk = None
blog.save() # blog.pk == 2
```

​	对于继承：

```python
class ThemeBlog(Blog):
    theme = models.CharField(max_length=200)

django_blog = ThemeBlog(name='Django', tagline='Django is easy', theme='python')
django_blog.save() # django_blog.pk == 3
```

```python
django_blog.pk = None
django_blog.id = None
django_blog.save() # django_blog.pk == 4
```

​	对于多对多，必须手动设置关系

```python
entry = Entry.objects.all()[0] # some previous entry
old_authors = entry.authors.all()
entry.pk = None
entry.save()
entry.authors.set(old_authors)  # 只设置了新 entry
```

​	对于一对一，必须复制相关对象，并赋值给新的对象属性，以满足限制条件。假设已经复制了 entry

```python
detail = EntryDetail.objects.all()[0]
detail.pk = None
detail.entry = entry
detail.save()
```

### 2.2.8 一次更新多个对象

```python
# Update all the headlines with pub_date in 2007.
Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')
```

```python
>>> b = Blog.objects.get(pk=1)

# Change every Entry so that it belongs to this Blog.
>>> Entry.objects.all().update(blog=b)	
```

​	update() 返回相匹配的行（可能不等于更新的行）。**唯一的限制就是只能访问一个数据库表：模型的主表**

```
>>> b = Blog.objects.get(pk=1)

# Update all the headlines belonging to this Blog.
>>> Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same')
```

​	**作为直接转化为SQL 的 update() 方法。作为批直接更新。不会调用 模型的 save()方法，忽略 pre_save 和 post_save 信号，honor the**
**[`auto_now`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.DateField.auto_now) field option。 如果想确保 QuerySet 中的每一个实例都调用 save() 方法保存，只需循环遍历调用。**

```python
for item in my_queryset:
    item.save()
```

​	F 表达式也同样适用。

```python
>>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)
```

​	但是不能操作其他表

```python
# This will raise a FieldError
>>> Entry.objects.update(headline=F('blog__name'))
```

### 2.2.9 相关联的对象

​	定义了模型之间的关系，模型实例有方便访问相关对象的API

#### one-to-many关系

##### 正向

​	定义关系的模型，直接使用属性访问。

```python
>>> e = Entry.objects.get(id=2)
>>> e.blog # Returns the related Blog object.
```

```python
>>> e = Entry.objects.get(id=2)
>>> e.blog = some_blog
>>> e.save()	# 更改之后需要 save() 才能保存到数据库
```

​	如果 外键 设置了 null= True， 可以直接设为 None，移除关系：

```python
>>> e = Entry.objects.get(id=2)
>>> e.blog = None
>>> e.save() # "UPDATE blog_entry SET blog_id = NULL ...;"
```

```python
>>> e = Entry.objects.get(id=2)		# 缓存了
>>> print(e.blog)  # Hits the database to retrieve the associated Blog.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
```

> Note that the [`select_related()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.select_related) [`QuerySet`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet) method recursively prepopulates the cache of all one-to-many relationships ahead of time. Example:

```python
>>> e = Entry.objects.select_related().get(id=2)
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
```

##### 反向

​	相关联的模型，Manager 有 XX_set()

```python
>>> b = Blog.objects.get(id=1)
>>> b.entry_set.all() # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
>>> b.entry_set.filter(headline__contains='Lennon')
>>> b.entry_set.count()
```

​	也可以覆盖上面的访问名称，但是需要在定义的时候就指定 **blog = ForeignKey(Blog, on_delete=models.CASCADE,**
**related_name='entries')**

即：

```python
>>> b = Blog.objects.get(id=1)
>>> b.entries.all() # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns QuerySets.
>>> b.entries.filter(headline__contains='Lennon')
>>> b.entries.count()
```

##### 使用自定义的反向 manager

 subclass of the [default manager](https://docs.djangoproject.com/en/1.11/topics/db/managers/#manager-names)

```python
from django.db import models

class Entry(models.Model):
    #...
    objects = models.Manager()  # Default Manager
    entries = EntryManager()    # Custom Manager  

b = Blog.objects.get(id=1)
b.entry_set(manager='entries').all()	# 如果实现 get_queryset() 
```

###### 其他处理相关对象的方法：

​	the [`ForeignKey`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ForeignKey) [`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager) has additional methods used to handle the
set of related objects。

`add(obj1, obj2, ...)`

`create(**kwargs)`：

`remove(obj1, obj2, ...)`

`clear()`

`set(objs)`

```python
b = Blog.objects.get(id=1)
b.entry_set.set([e1, e2])
```

#### many-to-many 关系

​	正向使用： 属性名

​	反向使用 ： 小写模型名_set

```python
e = Entry.objects.get(id=3)
e.authors.all() # Returns all Author objects for this Entry.
e.authors.count()
e.authors.filter(name__contains='John')

a = Author.objects.get(id=5)
a.entry_set.all() # Returns all Entry objects for this Author.
```

​	当然也可以指定 [`related_name`](https://docs.djangoproject.com/en/1.11/ref/models/fields/#django.db.models.ManyToManyField.related_name).

#### one-to-one 关系

```python
class EntryDetail(models.Model):
    entry = models.OneToOneField(Entry, on_delete=models.CASCADE)
    details = models.TextField()

ed = EntryDetail.objects.get(id=2)
ed.entry # Returns the related Entry object. 使用属性
```

​	反向使用：（访问[`Manager`](https://docs.djangoproject.com/en/1.11/topics/db/managers/#django.db.models.Manager)  ，但是只有一个 对象）

```python
e = Entry.objects.get(id=2)
e.entrydetail # returns the related EntryDetail object
```

#### 反向关系如何实现

​	其他 ORM需要 双边定义，Django 开发者认为这违反了 DRY（Don’t
Repeat Yourself），因一边进行定义。

​	 [`app registry`](https://docs.djangoproject.com/en/1.11/ref/applications/#django.apps.apps).使其成为可能。在导入时添加了关系。

#### 通过关联对象查询

​	如果 blog 对象的 id =5 

```python
Entry.objects.filter(blog=b) # Query using object instance
Entry.objects.filter(blog=b.id) # Query using id from instance
Entry.objects.filter(blog=5) # Query using id directly
```

### 2.2.10 使用原始 SQL

​	[Performing raw SQL queries](https://docs.djangoproject.com/en/1.11/topics/db/sql/).	

## 2.3 聚集（*aggregation*）

​	使用模型

```python
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()

class Publisher(models.Model):
    name = models.CharField(max_length=300)
    num_awards = models.IntegerField()

class Book(models.Model):
    name = models.CharField(max_length=300)
    pages = models.IntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    rating = models.FloatField()
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    pubdate = models.DateField()

class Store(models.Model):
    name = models.CharField(max_length=300)
    books = models.ManyToManyField(Book)
    registered_users = models.PositiveIntegerField()
```

### 2.3.1 简单说明

```python
# Total number of books.
>>> Book.objects.count()
2452

# Total number of books with publisher=BaloneyPress
>>> Book.objects.filter(publisher__name='BaloneyPress').count()
73

# Average price across all books.
>>> from django.db.models import Avg
>>> Book.objects.all().aggregate(Avg('price'))
{'price__avg': 34.35}

# Max price across all books.
>>> from django.db.models import Max
>>> Book.objects.all().aggregate(Max('price'))
{'price__max': Decimal('81.20')}

# Difference between the highest priced book and the average price of all books.
>>> from django.db.models import FloatField
>>> Book.objects.aggregate(
...     price_diff=Max('price', output_field=FloatField()) - Avg('price')))
{'price_diff': 46.85}

# All the following queries involve traversing the Book<->Publisher
# foreign key relationship backwards.

# Each publisher, each with a count of books as a "num_books" attribute.
>>> from django.db.models import Count
>>> pubs = Publisher.objects.annotate(num_books=Count('book'))
>>> pubs
<QuerySet [<Publisher: BaloneyPress>, <Publisher: SalamiPress>, ...]>
>>> pubs[0].num_books
73

# The top 5 publishers, in order by number of books.
>>> pubs = Publisher.objects.annotate(num_books=Count('book')).order_by('-num_books')[:5]
>>> pubs[0].num_books
1323
```

### 2.3.2  QuerySet 上的聚集

​	QuerySet 整体上 产生聚集：

```python
>>> from django.db.models import Avg
>>> Book.objects.all().aggregate(Avg('price'))
{'price__avg': 34.35}		

# 也可以不使用 all()
>>> Book.objects.aggregate(Avg('price'))
{'price__avg': 34.35}
```

​	可用的聚集函数 [QuerySet reference](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#aggregation-functions).

​	`aggregate()` 会终止 QuerySet ，返回字典{聚集的标识（属性和聚集函数生成）：计算的值}。如果想指定名称，在聚集语句中指定名称：

```python
>>> Book.objects.aggregate(average_price=Avg('price'))
{'average_price': 34.35}
```

​	如果想产生多个聚集，只需将参数加入 `aggregate()` ：

```python
>>> from django.db.models import Avg, Max, Min
>>> Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))
{'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')
```

### 2.3.3 QuerySet 每项的聚集

​	使用`annotate()` 语句，语法与`aggregate()` 相同。

```python
# Build an annotated queryset
>>> from django.db.models import Count
>>> q = Book.objects.annotate(Count('authors'))
# Interrogate the first object in the queryset
>>> q[0]
<Book: The Definitive Guide to Django>
>>> q[0].authors__count
2
# Interrogate the second object in the queryset
>>> q[1]
<Book: Practical Django Projects>
>>> q[1].authors__count
1
```

​	与 `aggregate()`不同的是，`annotate()` 的返回值仍然是 QuerySet。

#### 多个聚集联合？？？

​	在 `annotate()` 中使用多个聚合，由于使用联合，而不是子查询，因此会导致错误：

```python
>>> book = Book.objects.first()
>>> book.authors.count()
2
>>> book.store_set.count()
3
>>> q = Book.objects.annotate(Count('authors'), Count('store'))
>>> q[0].authors__count
6
>>> q[0].store__count
6
```

​	对于一般的聚合没法颁发避免，但是对于 Count 聚合，可以使用 `distinct`参数：

```python
>>> q = Book.objects.annotate(Count('authors', distinct=True), Count('store', distinct=True))
>>> q[0].authors__count
2
>>> q[0].store__count
3
```

### 2.3.4 联合与聚集

​	在聚合中可以使用` __` 来引用相关联的字段。Django会处理表的联合。 

​	`annotate()` 和`aggregate()` 都适用。

```python
>>> from django.db.models import Max, Min
>>> Store.objects.annotate(min_price=Min('books__price'), max_price=Max('books__price'))
 
    
>>> Store.objects.aggregate(min_price=Min('books__price'), max_price=Max('books__price'))


>>> Store.objects.aggregate(youngest_age=Min('books__authors__age'))	# 可以任意深度
```

#### 反向关系

​	使用相关对象的小写：

​	`Publisher` -> `Book` reverse foreign key 

​	`Author` -> `Book` reverse many-to-many 

```python
>>> from django.db.models import Count, Min, Sum, Avg
>>> Publisher.objects.annotate(Count('book'))

>>> Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))


>>> Author.objects.annotate(total_pages=Sum('book__pages'))
```

### 2.3.5 聚集和其他 QuerySet 语句

#### filter()  和 exclude()

​	用于聚合 filter() 和 exclude() 的结果：

```python
>>> from django.db.models import Count, Avg
>>> Book.objects.filter(name__startswith="Django").annotate(num_authors=Count('authors'))

>>> Book.objects.filter(name__startswith="Django").aggregate(Avg('price'))
```

##### annotate 过滤

```python
>>> Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)		# 启的别名与 字段一样使用
```

##### annotate()  和 filter() 语句的顺序

Given:

- Publisher A has two books with ratings 4 and 5.
- Publisher B has two books with ratings 1 and 4.
- Publisher C has one book with rating 1.

```python
>>> a, b = Publisher.objects.annotate(num_books=Count('book', distinct=True)).filter(book__rating__gt=3.0)
>>> a, a.num_books
(<Publisher: A>, 2)
>>> b, b.num_books
(<Publisher: B>, 2)

>>> a, b = Publisher.objects.filter(book__rating__gt=3.0).annotate(num_books=Count('book'))
>>> a, a.num_books
(<Publisher: A>, 2)
>>> b, b.num_books
(<Publisher: B>, 1)
```

```python
>>> a, b = Publisher.objects.annotate(avg_rating=Avg('book__rating')).filter(book__rating__gt=3.0)
>>> a, a.avg_rating
(<Publisher: A>, 4.5)  # (5+4)/2
>>> b, b.avg_rating
(<Publisher: B>, 2.5)  # (1+4)/2

>>> a, b = Publisher.objects.filter(book__rating__gt=3.0).annotate(avg_rating=Avg('book__rating'))
>>> a, a.avg_rating
(<Publisher: A>, 4.5)  # (5+4)/2
>>> b, b.avg_rating
(<Publisher: B>, 4.0)  # 4/1 (book with rating 1 excluded)
```

#### order_by()

```python
>>> Book.objects.annotate(num_authors=Count('authors')).order_by('num_authors')
```

#### values()

> the original results are grouped according to the unique combinations of the fields specified in the`values()` clause. An annotation is then provided for each unique group; the annotation is computed over all members of the group.

```python
>>> Author.objects.annotate(average_rating=Avg('book__rating'))

>>> Author.objects.values('name').annotate(average_rating=Avg('book__rating')) #This means if you have two authors with the same name, their results will be merged into a single result in the output of the query; the average will be computed as the average over the books written by both authors.
```

##### annotate()  和 values() 语句的顺序

```python
>>> Author.objects.annotate(average_rating=Avg('book__rating')).values('name', 'average_rating')# This will now yield one unique result for each author; however, only the author’s name and the average_rating annotation will be returned in the output data.
```

> If the `values()` clause precedes the `annotate()` clause, any annotations will be automatically added to the result set. However, if the `values()` clause is applied after the `annotate()` clause, you need to explicitly include the aggregate column. values() 在后需手动添加。

##### 与默认排序或order_by() 的交互

```python
from django.db import models

class Item(models.Model):
    name = models.CharField(max_length=10)
    data = models.IntegerField()

    class Meta:
        ordering = ["name"]
        

        
# Warning: not quite correct!
Item.objects.values("data").annotate(Count("id"))
# group the Item objects by their common data values and then count the number of id values in each group. this query will group by distinct (data, name) 


Item.objects.values("data").annotate(Count("id")).order_by()
# clearing any ordering in the query，
```

> You might reasonably ask why Django doesn’t remove the extraneous columns for you. The main reason is consistency with `distinct()` and other places: Django **never** removes ordering constraints that you have specified (and we can’t change those other methods’ behavior, as that would violate our [API stability](https://docs.djangoproject.com/en/1.11/misc/api-stability/) policy).

#### `aggregate`（）和  `annotate()` 连接

```python
>>> from django.db.models import Count, Avg
>>> Book.objects.annotate(num_authors=Count('authors')).aggregate(Avg('num_authors'))
{'num_authors__avg': 1.66}
```

## 2.4 搜索

### 2.4.1 用例

#### 标准文本查询

```python
>>> Author.objects.filter(name__contains='Terry')
[<Author: Terry Gilliam>, <Author: Terry Jones>]
```

#### 数据库的高级比较函数

​	Django 针对 PostgreSQL，提供了 [a selection of database specific tools](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/) 。

​	[`unaccented comparison`](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/lookups/#std:fieldlookup-unaccent):

```python
>>> Author.objects.filter(name__unaccent__icontains='Helen')
[<Author: Helen Mirren>, <Author: Helena Bonham Carter>, <Author: Hélène Joy>]
```

​	[`trigram_similar`](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/lookups/#std:fieldlookup-trigram_similar) 

```python
>>> Author.objects.filter(name__unaccent__lower__trigram_similar='Hélène')
[<Author: Helen Mirren>, <Author: Hélène Joy>]
```

#### 基于文档的搜索

some of the most prominent are [Elastic](https://www.elastic.co/) and [Solr](http://lucene.apache.org/solr/).

- Ignoring “stop words” such as “a”, “the”, “and”.
- Stemming words, so that “pony” and “ponies” are considered similar.
- Weighting words based on different criteria such as how frequently theyappear in the text, or the importance of the fields, such as the title orkeywords, that they appear in.

##### PostgreSQL 的支持

​	[`django.contrib.postgres`](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/#module-django.contrib.postgres)    [Full text search](https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/)  

```python
>>> Entry.objects.filter(body_text__search='cheese') # 搜索 提到cheese
[<Entry: Cheese on Toast recipes>, <Entry: Pizza recipes>]
```

## 2.5 管理类



## 2.6 原始数据库查询



## 2.7 数据库事务



## 2.8 多数据库



## 2.9 表空间



## 2.10 数据库访问优化